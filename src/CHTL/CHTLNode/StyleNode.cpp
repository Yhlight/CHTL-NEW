#include "StyleNode.h"
#include "Visitor.h"
#include <regex>
#include <sstream>
#include <algorithm>
#include <unordered_set>

namespace CHTL {

StyleNode::StyleNode(size_t line, size_t column)
    : CHTLBaseNode(CHTLNodeType::STYLE_NODE, "style", line, column),
      m_HasContextReference(false), m_HasAutoSelector(false) {
}

void StyleNode::AddStyleRule(const StyleRule& rule) {
    m_StyleRules.push_back(rule);
    
    // 检查是否为自动生成的选择器
    if (rule.Selector.front() == '.' || rule.Selector.front() == '#') {
        AddAutoGeneratedSelector(rule.Selector);
    }
    
    // 检查是否有上下文引用
    if (rule.Selector.find('&') != std::string::npos) {
        AddContextReference(rule.Selector);
    }
}

void StyleNode::AddSelectorStyle(const std::string& selector, 
                                const std::unordered_map<std::string, std::string>& properties) {
    StyleRule rule(selector);
    rule.Properties = properties;
    
    // 判断是否为内联样式（直接在style{}内部的属性）
    if (selector.empty()) {
        rule.IsInlineStyle = true;
        
        // 添加到内联属性
        for (const auto& prop : properties) {
            AddInlineProperty(prop.first, prop.second);
        }
    }
    else {
        // 全局样式（类选择器、ID选择器等）
        rule.IsGlobalStyle = true;
    }
    
    AddStyleRule(rule);
}

StyleRule* StyleNode::GetStyleRule(const std::string& selector) {
    for (auto& rule : m_StyleRules) {
        if (rule.Selector == selector) {
            return &rule;
        }
    }
    
    return nullptr;
}

void StyleNode::AddInlineProperty(const std::string& property, const std::string& value) {
    m_InlineProperties[property] = ProcessCSSValue(value);
}

void StyleNode::AddAutoGeneratedSelector(const std::string& selector) {
    if (std::find(m_AutoGeneratedSelectors.begin(), m_AutoGeneratedSelectors.end(), selector) 
        == m_AutoGeneratedSelectors.end()) {
        m_AutoGeneratedSelectors.push_back(selector);
        m_HasAutoSelector = true;
    }
}

void StyleNode::AddContextReference(const std::string& reference) {
    if (std::find(m_ContextReferences.begin(), m_ContextReferences.end(), reference) 
        == m_ContextReferences.end()) {
        m_ContextReferences.push_back(reference);
        m_HasContextReference = true;
    }
}

std::string StyleNode::ResolveContextReference(const std::string& contextClass, const std::string& contextId) const {
    // 局部style优先选择class
    if (!contextClass.empty()) {
        return "." + contextClass;
    }
    else if (!contextId.empty()) {
        return "#" + contextId;
    }
    
    return ""; // 无法解析
}

void StyleNode::AddTemplateUsage(const std::string& templateUsage) {
    m_TemplateUsages.push_back(templateUsage);
}

void StyleNode::AddCustomUsage(const std::string& customUsage) {
    m_CustomUsages.push_back(customUsage);
}

void StyleNode::AddVariableReference(const std::string& variableRef) {
    m_VariableReferences.push_back(variableRef);
}

void StyleNode::AddDeletedProperty(const std::string& property) {
    m_DeletedProperties.push_back(property);
}

void StyleNode::AddDeletedInherit(const std::string& inherit) {
    m_DeletedInherits.push_back(inherit);
}

std::string StyleNode::GenerateInlineCSS() const {
    if (m_InlineProperties.empty()) {
        return "";
    }
    
    std::ostringstream css;
    bool first = true;
    
    for (const auto& prop : m_InlineProperties) {
        if (!first) {
            css << "; ";
        }
        css << prop.first << ": " << prop.second;
        first = false;
    }
    
    return css.str();
}

std::string StyleNode::GenerateGlobalCSS() const {
    std::ostringstream css;
    
    for (const auto& rule : m_StyleRules) {
        if (rule.IsGlobalStyle && !rule.Selector.empty()) {
            css << rule.Selector << " {\n";
            
            for (const auto& prop : rule.Properties) {
                css << "  " << prop.first << ": " << prop.second << ";\n";
            }
            
            css << "}\n\n";
        }
    }
    
    return css.str();
}

std::string StyleNode::GenerateFullCSS() const {
    std::ostringstream css;
    
    // 生成全局样式
    std::string globalCSS = GenerateGlobalCSS();
    if (!globalCSS.empty()) {
        css << globalCSS;
    }
    
    return css.str();
}

void StyleNode::ParseStyleContent(const std::string& styleContent) {
    // 解析样式内容，提取选择器和属性
    
    // 解析内联样式（直接的CSS属性）
    std::regex inlinePropertyPattern(R"(([a-zA-Z\-]+)\s*:\s*([^;]+);?)");
    std::sregex_iterator inlineIter(styleContent.begin(), styleContent.end(), inlinePropertyPattern);
    std::sregex_iterator end;
    
    for (; inlineIter != end; ++inlineIter) {
        std::smatch match = *inlineIter;
        std::string property = match[1].str();
        std::string value = match[2].str();
        
        // 验证CSS属性
        if (IsValidCSSProperty(property)) {
            AddInlineProperty(property, value);
        }
    }
    
    // 解析选择器块
    std::regex selectorBlockPattern(R"(([.#&][a-zA-Z0-9\-_:]*)\s*\{([^}]*)\})");
    std::sregex_iterator selectorIter(styleContent.begin(), styleContent.end(), selectorBlockPattern);
    
    for (; selectorIter != end; ++selectorIter) {
        std::smatch match = *selectorIter;
        std::string selector = match[1].str();
        std::string propertyBlock = match[2].str();
        
        // 解析属性块
        auto properties = ParseCSSProperties(propertyBlock);
        AddSelectorStyle(selector, properties);
    }
    
    // 解析模板使用（@Style）
    std::regex templatePattern(R"(@Style\s+([a-zA-Z][a-zA-Z0-9_]*)\s*;?)");
    std::sregex_iterator templateIter(styleContent.begin(), styleContent.end(), templatePattern);
    
    for (; templateIter != end; ++templateIter) {
        std::smatch match = *templateIter;
        std::string templateName = match[1].str();
        AddTemplateUsage("@Style " + templateName);
    }
    
    // 解析变量引用（ThemeColor(tableColor)）
    std::regex variablePattern(R"(([a-zA-Z][a-zA-Z0-9_]*)\(([a-zA-Z][a-zA-Z0-9_]*)\))");
    std::sregex_iterator variableIter(styleContent.begin(), styleContent.end(), variablePattern);
    
    for (; variableIter != end; ++variableIter) {
        std::smatch match = *variableIter;
        std::string varGroup = match[1].str();
        std::string varName = match[2].str();
        AddVariableReference(varGroup + "(" + varName + ")");
    }
    
    // 解析删除操作（delete）
    std::regex deletePattern(R"(delete\s+([^;]+);?)");
    std::sregex_iterator deleteIter(styleContent.begin(), styleContent.end(), deletePattern);
    
    for (; deleteIter != end; ++deleteIter) {
        std::smatch match = *deleteIter;
        std::string deleteTarget = match[1].str();
        
        if (deleteTarget.find("@Style") != std::string::npos) {
            AddDeletedInherit(deleteTarget);
        }
        else {
            AddDeletedProperty(deleteTarget);
        }
    }
}

std::unordered_map<std::string, std::string> StyleNode::ParseCSSProperties(const std::string& propertyBlock) {
    std::unordered_map<std::string, std::string> properties;
    
    std::regex propertyPattern(R"(([a-zA-Z\-]+)\s*:\s*([^;]+);?)");
    std::sregex_iterator iter(propertyBlock.begin(), propertyBlock.end(), propertyPattern);
    std::sregex_iterator end;
    
    for (; iter != end; ++iter) {
        std::smatch match = *iter;
        std::string property = match[1].str();
        std::string value = match[2].str();
        
        // 清理属性值
        value.erase(std::remove_if(value.begin(), value.end(), 
                   [](char c) { return c == '\n' || c == '\r'; }), value.end());
        
        if (IsValidCSSProperty(property)) {
            properties[property] = ProcessCSSValue(value);
        }
    }
    
    return properties;
}

bool StyleNode::IsValidCSSProperty(const std::string& property) const {
    // 常见CSS属性验证
    static const std::unordered_set<std::string> validProperties = {
        "color", "background-color", "background", "font-size", "font-family", "font-weight",
        "width", "height", "margin", "padding", "border", "border-radius", "display",
        "position", "top", "left", "right", "bottom", "z-index", "opacity", "visibility",
        "overflow", "text-align", "line-height", "letter-spacing", "text-decoration",
        "transform", "transition", "animation", "box-shadow", "text-shadow", "cursor",
        "float", "clear", "flex", "flex-direction", "justify-content", "align-items",
        "grid", "grid-template-columns", "grid-template-rows", "gap"
    };
    
    // 检查是否为已知属性或vendor前缀属性
    if (validProperties.find(property) != validProperties.end()) {
        return true;
    }
    
    // 检查vendor前缀（-webkit-、-moz-、-ms-、-o-）
    if (property.find("-webkit-") == 0 || property.find("-moz-") == 0 ||
        property.find("-ms-") == 0 || property.find("-o-") == 0) {
        return true;
    }
    
    // 检查CSS变量（--）
    if (property.find("--") == 0) {
        return true;
    }
    
    return false;
}

std::string StyleNode::ProcessCSSValue(const std::string& value) const {
    std::string processedValue = value;
    
    // 移除首尾空白
    processedValue.erase(0, processedValue.find_first_not_of(" \t\n\r"));
    processedValue.erase(processedValue.find_last_not_of(" \t\n\r") + 1);
    
    // 处理无修饰字面量
    if (processedValue.find('"') == std::string::npos && 
        processedValue.find('\'') == std::string::npos) {
        // 无修饰字面量，保持原样
        return processedValue;
    }
    
    // 处理引号字符串
    if ((processedValue.front() == '"' && processedValue.back() == '"') ||
        (processedValue.front() == '\'' && processedValue.back() == '\'')) {
        // 去除引号
        return processedValue.substr(1, processedValue.length() - 2);
    }
    
    return processedValue;
}

std::string StyleNode::ProcessPseudoSelectors(const std::string& selector, 
                                             const std::unordered_map<std::string, std::string>& properties) {
    std::string processedSelector = selector;
    
    // 处理&引用的伪类和伪元素
    if (selector.find('&') != std::string::npos) {
        // 这里需要根据上下文解析&引用
        // 暂时返回原选择器，实际解析在生成阶段进行
    }
    
    return processedSelector;
}

void StyleNode::Accept(CHTLNodeVisitor* visitor) {
    if (visitor) {
        visitor->VisitStyleNode(this);
    }
}

std::unique_ptr<CHTLBaseNode> StyleNode::Clone() const {
    auto cloned = std::make_unique<StyleNode>(GetLine(), GetColumn());
    
    // 复制基础属性
    cloned->SetContent(GetContent());
    cloned->SetNamespace(GetNamespace());
    
    // 复制样式规则
    cloned->m_StyleRules = m_StyleRules;
    cloned->m_InlineProperties = m_InlineProperties;
    cloned->m_AutoGeneratedSelectors = m_AutoGeneratedSelectors;
    cloned->m_ContextReferences = m_ContextReferences;
    cloned->m_TemplateUsages = m_TemplateUsages;
    cloned->m_CustomUsages = m_CustomUsages;
    cloned->m_VariableReferences = m_VariableReferences;
    cloned->m_DeletedProperties = m_DeletedProperties;
    cloned->m_DeletedInherits = m_DeletedInherits;
    cloned->m_HasContextReference = m_HasContextReference;
    cloned->m_HasAutoSelector = m_HasAutoSelector;
    
    return cloned;
}

std::string StyleNode::ToString(int indent) const {
    std::ostringstream oss;
    std::string indentStr = GenerateIndent(indent);
    
    oss << indentStr << "StyleNode";
    
    if (HasInlineStyle()) {
        oss << " [Inline: " << m_InlineProperties.size() << " props]";
    }
    
    if (m_HasAutoSelector) {
        oss << " [Auto: " << m_AutoGeneratedSelectors.size() << " selectors]";
    }
    
    if (m_HasContextReference) {
        oss << " [Context: " << m_ContextReferences.size() << " refs]";
    }
    
    if (!m_TemplateUsages.empty()) {
        oss << " [Templates: " << m_TemplateUsages.size() << "]";
    }
    
    if (!m_CustomUsages.empty()) {
        oss << " [Customs: " << m_CustomUsages.size() << "]";
    }
    
    if (!m_VariableReferences.empty()) {
        oss << " [Variables: " << m_VariableReferences.size() << "]";
    }
    
    oss << " @(" << GetLine() << ":" << GetColumn() << ")\n";
    
    // 输出样式规则详情
    if (!m_StyleRules.empty()) {
        oss << indentStr << "  Rules:\n";
        for (const auto& rule : m_StyleRules) {
            oss << indentStr << "    " << rule.Selector << " {" << rule.Properties.size() << " props}";
            if (rule.IsInlineStyle) oss << " [Inline]";
            if (rule.IsGlobalStyle) oss << " [Global]";
            oss << "\n";
        }
    }
    
    // 输出内联属性
    if (!m_InlineProperties.empty()) {
        oss << indentStr << "  Inline Properties:\n";
        for (const auto& prop : m_InlineProperties) {
            oss << indentStr << "    " << prop.first << ": " << prop.second << "\n";
        }
    }
    
    // 输出自动生成的选择器
    if (!m_AutoGeneratedSelectors.empty()) {
        oss << indentStr << "  Auto Selectors: ";
        for (size_t i = 0; i < m_AutoGeneratedSelectors.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << m_AutoGeneratedSelectors[i];
        }
        oss << "\n";
    }
    
    // 输出上下文引用
    if (!m_ContextReferences.empty()) {
        oss << indentStr << "  Context References: ";
        for (size_t i = 0; i < m_ContextReferences.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << m_ContextReferences[i];
        }
        oss << "\n";
    }
    
    return oss.str();
}

} // namespace CHTL