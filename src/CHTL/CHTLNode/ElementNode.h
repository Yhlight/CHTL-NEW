#pragma once

#include "CHTLBaseNode.h"
#include <vector>
#include <unordered_set>

namespace CHTL {

/**
 * CHTL元素节点
 * 表示HTML元素，支持所有HTML元素类型
 */
class ElementNode : public CHTLBaseNode {
private:
    std::string m_TagName;                              // HTML标签名
    bool m_IsSelfClosing;                              // 是否为自闭合标签
    bool m_IsBlockLevel;                               // 是否为块级元素
    std::vector<std::unique_ptr<CHTLBaseNode>> m_StyleNodes;  // 局部样式节点
    std::vector<std::unique_ptr<CHTLBaseNode>> m_ScriptNodes; // 局部脚本节点
    std::unordered_set<std::string> m_Constraints;     // 约束列表（except）
    
    // 自动化选择器相关
    std::vector<std::string> m_AutoGeneratedClasses;   // 自动生成的类名列表
    std::vector<std::string> m_AutoGeneratedIds;       // 自动生成的ID列表

public:
    /**
     * 构造函数
     * @param tagName HTML标签名
     * @param line 行号
     * @param column 列号
     */
    ElementNode(const std::string& tagName, size_t line = 0, size_t column = 0);
    
    /**
     * 析构函数
     */
    ~ElementNode() override = default;
    
    /**
     * 获取标签名
     * @return 标签名
     */
    const std::string& GetTagName() const { return m_TagName; }
    
    /**
     * 设置标签名
     * @param tagName 新标签名
     */
    void SetTagName(const std::string& tagName);
    
    /**
     * 检查是否为自闭合标签
     * @return 是否为自闭合标签
     */
    bool IsSelfClosing() const { return m_IsSelfClosing; }
    
    /**
     * 设置是否为自闭合标签
     * @param selfClosing 是否自闭合
     */
    void SetSelfClosing(bool selfClosing) { m_IsSelfClosing = selfClosing; }
    
    /**
     * 检查是否为块级元素
     * @return 是否为块级元素
     */
    bool IsBlockLevel() const { return m_IsBlockLevel; }
    
    /**
     * 设置是否为块级元素
     * @param blockLevel 是否块级
     */
    void SetBlockLevel(bool blockLevel) { m_IsBlockLevel = blockLevel; }
    
    // 样式节点管理
    /**
     * 添加样式节点
     * @param styleNode 样式节点
     */
    void AddStyleNode(std::unique_ptr<CHTLBaseNode> styleNode);
    
    /**
     * 获取所有样式节点
     * @return 样式节点列表
     */
    const std::vector<std::unique_ptr<CHTLBaseNode>>& GetStyleNodes() const { return m_StyleNodes; }
    
    /**
     * 检查是否有局部样式
     * @return 是否有局部样式
     */
    bool HasLocalStyle() const { return !m_StyleNodes.empty(); }
    
    // 脚本节点管理（局部script属于CHTL）
    /**
     * 添加脚本节点
     * @param scriptNode 脚本节点
     */
    void AddScriptNode(std::unique_ptr<CHTLBaseNode> scriptNode);
    
    /**
     * 获取所有脚本节点
     * @return 脚本节点列表
     */
    const std::vector<std::unique_ptr<CHTLBaseNode>>& GetScriptNodes() const { return m_ScriptNodes; }
    
    /**
     * 检查是否有局部脚本
     * @return 是否有局部脚本
     */
    bool HasLocalScript() const { return !m_ScriptNodes.empty(); }
    
    // 约束管理
    /**
     * 添加约束
     * @param constraint 约束条件
     */
    void AddConstraint(const std::string& constraint);
    
    /**
     * 检查约束
     * @param elementType 元素类型
     * @return 是否违反约束
     */
    bool CheckConstraint(const std::string& elementType) const;
    
    /**
     * 获取所有约束
     * @return 约束集合
     */
    const std::unordered_set<std::string>& GetConstraints() const { return m_Constraints; }
    
    // 自动化选择器管理
    /**
     * 添加自动生成的类名
     * @param className 类名
     */
    void AddAutoGeneratedClass(const std::string& className);
    
    /**
     * 添加自动生成的ID
     * @param idName ID名
     */
    void AddAutoGeneratedId(const std::string& idName);
    
    /**
     * 获取第一个自动类名（用于&引用）
     * @return 第一个类名
     */
    std::string GetFirstAutoClass() const;
    
    /**
     * 获取第一个自动ID（用于&引用）
     * @return 第一个ID
     */
    std::string GetFirstAutoId() const;
    
    /**
     * 应用选择器自动化规则
     * @param disableClassAuto 是否禁用类自动化
     * @param disableIdAuto 是否禁用ID自动化
     */
    void ApplySelectorAutomation(bool disableClassAuto = false, bool disableIdAuto = false);
    
    // HTML生成相关
    /**
     * 生成开始标签
     * @return HTML开始标签
     */
    std::string GenerateOpenTag() const;
    
    /**
     * 生成结束标签
     * @return HTML结束标签
     */
    std::string GenerateCloseTag() const;
    
    /**
     * 生成完整的HTML元素
     * @return 完整HTML元素
     */
    std::string GenerateHTMLElement() const;
    
    /**
     * 生成内联样式
     * @return 内联样式字符串
     */
    std::string GenerateInlineStyle() const;
    
    // 访问者模式实现
    void Accept(CHTLNodeVisitor* visitor) override;
    
    // 克隆实现
    std::unique_ptr<CHTLBaseNode> Clone() const override;
    
    // 调试输出
    std::string ToString(int indent = 0) const override;

private:
    /**
     * 初始化HTML标签属性
     */
    void InitializeHTMLTagProperties();
    
    /**
     * 检查是否为有效的HTML标签
     * @param tagName 标签名
     * @return 是否有效
     */
    bool IsValidHTMLTag(const std::string& tagName) const;
    
    /**
     * 检查是否为自闭合标签
     * @param tagName 标签名
     * @return 是否为自闭合标签
     */
    bool IsSelfClosingTag(const std::string& tagName) const;
    
    /**
     * 检查是否为块级标签
     * @param tagName 标签名
     * @return 是否为块级标签
     */
    bool IsBlockLevelTag(const std::string& tagName) const;
    
    /**
     * 处理CE对等式（:和=等价）
     * @param attributes 属性映射
     */
    void ProcessCEEquivalence(std::unordered_map<std::string, std::string>& attributes);
    
    /**
     * 处理上下文推导（&引用）
     * @param styleContent 样式内容
     * @return 处理后的样式内容
     */
    std::string ProcessContextReference(const std::string& styleContent);
};

} // namespace CHTL