# ç»Ÿä¸€æ‰«æå™¨æ¶æ„è¯´æ˜

## ğŸ—ï¸ æ¶æ„æ¦‚è¿°

**CHTLUnifiedScanner (ç»Ÿä¸€æ‰«æå™¨)** æ˜¯CHTLç¼–è¯‘å™¨çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ç²¾å‡†çš„ä»£ç åˆ‡å‰²å’Œç‰‡æ®µç®¡ç†ã€‚å®ƒé‡‡ç”¨åˆ›æ–°çš„**å¯å˜é•¿åº¦åˆ‡ç‰‡æŠ€æœ¯**å’Œ**æœ€å°è¯­æ³•å•å…ƒåˆ‡å‰²**ï¼Œå®ç°äº†å¯¹CHTLã€CHTL JSã€CSSã€JavaScriptç­‰å¤šç§è¯­è¨€çš„æ™ºèƒ½è¯†åˆ«å’Œåˆ†ç¦»ã€‚

### ğŸ¯ è®¾è®¡ç›®æ ‡

- **ç²¾å‡†åˆ‡å‰²** - å‡†ç¡®è¯†åˆ«ä¸åŒè¯­è¨€çš„ä»£ç è¾¹ç•Œ
- **æ™ºèƒ½åˆ†ç±»** - è‡ªåŠ¨åˆ†ç±»ä»£ç ç‰‡æ®µç±»å‹
- **é«˜æ•ˆå¤„ç†** - æ”¯æŒå¤§æ–‡ä»¶å’Œå¤æ‚åµŒå¥—ç»“æ„
- **æ‰©å±•æ€§** - æ”¯æŒæ–°è¯­è¨€ç±»å‹çš„æ‰©å±•
- **å®¹é”™æ€§** - å¤„ç†è¯­æ³•é”™è¯¯å’Œè¾¹ç•Œæƒ…å†µ

---

## ğŸ”§ æ ¸å¿ƒæŠ€æœ¯

### ğŸ“ å¯å˜é•¿åº¦åˆ‡ç‰‡æŠ€æœ¯

ç»Ÿä¸€æ‰«æå™¨é‡‡ç”¨åŠ¨æ€é•¿åº¦åˆ†æï¼Œæ ¹æ®è¯­æ³•ç»“æ„è‡ªåŠ¨è°ƒæ•´åˆ‡ç‰‡å¤§å°ï¼š

```cpp
class CHTLUnifiedScanner {
private:
    /**
     * å¯å˜é•¿åº¦åˆ‡ç‰‡é…ç½®
     */
    struct SliceConfig {
        size_t MinSliceSize = 1;        // æœ€å°åˆ‡ç‰‡å¤§å°
        size_t MaxSliceSize = 10000;    // æœ€å¤§åˆ‡ç‰‡å¤§å°
        size_t DefaultSliceSize = 100;  // é»˜è®¤åˆ‡ç‰‡å¤§å°
        bool AdaptiveSlicing = true;    // è‡ªé€‚åº”åˆ‡ç‰‡
        bool ContextAware = true;       // ä¸Šä¸‹æ–‡æ„ŸçŸ¥
    };
    
    /**
     * åŠ¨æ€è°ƒæ•´åˆ‡ç‰‡å¤§å°
     * @param context å½“å‰è¯­æ³•ä¸Šä¸‹æ–‡
     * @param complexity ä»£ç å¤æ‚åº¦
     * @return æ¨èçš„åˆ‡ç‰‡å¤§å°
     */
    size_t CalculateOptimalSliceSize(const SyntaxContext& context, 
                                   double complexity) {
        size_t baseSize = m_SliceConfig.DefaultSliceSize;
        
        // æ ¹æ®å¤æ‚åº¦è°ƒæ•´
        if (complexity > 0.8) {
            baseSize = m_SliceConfig.MinSliceSize;  // å¤æ‚ä»£ç å°åˆ‡ç‰‡
        } else if (complexity < 0.3) {
            baseSize = m_SliceConfig.MaxSliceSize;  // ç®€å•ä»£ç å¤§åˆ‡ç‰‡
        }
        
        // æ ¹æ®ä¸Šä¸‹æ–‡è°ƒæ•´
        if (context.IsNestedStructure) {
            baseSize /= 2;  // åµŒå¥—ç»“æ„å‡åŠ
        }
        
        if (context.HasMixedLanguages) {
            baseSize /= 3;  // æ··åˆè¯­è¨€æ›´å°åˆ‡ç‰‡
        }
        
        return std::clamp(baseSize, 
                         m_SliceConfig.MinSliceSize, 
                         m_SliceConfig.MaxSliceSize);
    }
};
```

### âš—ï¸ æœ€å°è¯­æ³•å•å…ƒåˆ‡å‰²

æ‰«æå™¨èƒ½å¤Ÿè¯†åˆ«å„ç§è¯­è¨€çš„æœ€å°è¯­æ³•å•å…ƒï¼Œç¡®ä¿åˆ‡å‰²ä¸ä¼šç ´åè¯­æ³•ç»“æ„ï¼š

```cpp
/**
 * è¯­æ³•å•å…ƒç±»å‹
 */
enum class SyntaxUnitType {
    CHTL_ELEMENT,           // CHTLå…ƒç´ 
    CHTL_TEMPLATE,          // CHTLæ¨¡æ¿
    CHTL_CUSTOM,            // CHTLè‡ªå®šä¹‰
    CHTL_STYLE_BLOCK,       // CHTLæ ·å¼å—
    CHTL_SCRIPT_BLOCK,      // CHTLè„šæœ¬å—
    CHTLJS_LISTEN,          // CHTL JSç›‘å¬å™¨
    CHTLJS_DELEGATE,        // CHTL JSå§”æ‰˜
    CHTLJS_ANIMATE,         // CHTL JSåŠ¨ç”»
    CHTLJS_VIR_OBJECT,      // CHTL JSè™šæ‹Ÿå¯¹è±¡
    CSS_RULE,               // CSSè§„åˆ™
    CSS_SELECTOR,           // CSSé€‰æ‹©å™¨
    JS_FUNCTION,            // JavaScriptå‡½æ•°
    JS_CLASS,               // JavaScriptç±»
    JS_EXPRESSION,          // JavaScriptè¡¨è¾¾å¼
    MIXED_FRAGMENT,         // æ··åˆç‰‡æ®µ
    UNKNOWN                 // æœªçŸ¥ç±»å‹
};

/**
 * æœ€å°è¯­æ³•å•å…ƒ
 */
struct SyntaxUnit {
    SyntaxUnitType Type;
    size_t StartPosition;
    size_t EndPosition;
    size_t Length;
    std::string Content;
    int NestingLevel;
    std::vector<SyntaxUnit> ChildUnits;
    std::unordered_map<std::string, std::string> Attributes;
};

class SyntaxUnitAnalyzer {
public:
    /**
     * åˆ†ææœ€å°è¯­æ³•å•å…ƒ
     * @param code æºä»£ç 
     * @param startPos å¼€å§‹ä½ç½®
     * @return è¯­æ³•å•å…ƒä¿¡æ¯
     */
    SyntaxUnit AnalyzeMinimalUnit(const std::string& code, size_t startPos) {
        SyntaxUnit unit;
        unit.StartPosition = startPos;
        
        // è¯†åˆ«è¯­æ³•å•å…ƒç±»å‹
        unit.Type = IdentifySyntaxType(code, startPos);
        
        // è®¡ç®—å•å…ƒè¾¹ç•Œ
        auto boundaries = CalculateUnitBoundaries(code, startPos, unit.Type);
        unit.EndPosition = boundaries.EndPos;
        unit.Length = boundaries.Length;
        
        // æå–å†…å®¹
        unit.Content = code.substr(startPos, unit.Length);
        
        // åˆ†æåµŒå¥—ç»“æ„
        if (HasNestedStructure(unit.Type)) {
            unit.ChildUnits = AnalyzeChildUnits(unit.Content);
            unit.NestingLevel = CalculateNestingLevel(unit.ChildUnits);
        }
        
        // æå–å±æ€§
        unit.Attributes = ExtractUnitAttributes(unit.Content, unit.Type);
        
        return unit;
    }

private:
    /**
     * è¯†åˆ«è¯­æ³•ç±»å‹
     */
    SyntaxUnitType IdentifySyntaxType(const std::string& code, size_t pos) {
        // CHTLè¯­æ³•è¯†åˆ«
        if (IsAtCHTLElement(code, pos)) return SyntaxUnitType::CHTL_ELEMENT;
        if (IsAtTemplate(code, pos)) return SyntaxUnitType::CHTL_TEMPLATE;
        if (IsAtCustom(code, pos)) return SyntaxUnitType::CHTL_CUSTOM;
        if (IsAtStyleBlock(code, pos)) return SyntaxUnitType::CHTL_STYLE_BLOCK;
        if (IsAtScriptBlock(code, pos)) return SyntaxUnitType::CHTL_SCRIPT_BLOCK;
        
        // CHTL JSè¯­æ³•è¯†åˆ«
        if (IsAtListen(code, pos)) return SyntaxUnitType::CHTLJS_LISTEN;
        if (IsAtDelegate(code, pos)) return SyntaxUnitType::CHTLJS_DELEGATE;
        if (IsAtAnimate(code, pos)) return SyntaxUnitType::CHTLJS_ANIMATE;
        if (IsAtVirObject(code, pos)) return SyntaxUnitType::CHTLJS_VIR_OBJECT;
        
        // CSSè¯­æ³•è¯†åˆ«
        if (IsAtCSSRule(code, pos)) return SyntaxUnitType::CSS_RULE;
        
        // JavaScriptè¯­æ³•è¯†åˆ«
        if (IsAtJSFunction(code, pos)) return SyntaxUnitType::JS_FUNCTION;
        if (IsAtJSClass(code, pos)) return SyntaxUnitType::JS_CLASS;
        
        return SyntaxUnitType::UNKNOWN;
    }
};
```

---

## ğŸ¯ å››ç¼–è¯‘å™¨åè°ƒæ¶æ„

### ğŸ¼ ç¼–è¯‘å™¨è°ƒåº¦ç³»ç»Ÿ

```cpp
/**
 * ç¼–è¯‘å™¨è°ƒåº¦å™¨
 * åè°ƒå››ä¸ªä¸“é—¨ç¼–è¯‘å™¨çš„å·¥ä½œ
 */
class CompilerDispatcher {
private:
    // å››ä¸ªä¸“é—¨ç¼–è¯‘å™¨
    std::unique_ptr<CHTLCompiler> m_CHTLCompiler;           // CHTLç¼–è¯‘å™¨
    std::unique_ptr<CHTLJSCompiler> m_CHTLJSCompiler;       // CHTL JSç¼–è¯‘å™¨
    std::unique_ptr<CSSCompiler> m_CSSCompiler;             // CSSç¼–è¯‘å™¨ (ANTLR)
    std::unique_ptr<JavaScriptCompiler> m_JSCompiler;       // JSç¼–è¯‘å™¨ (ANTLR)
    
    // æ ¸å¿ƒç»„ä»¶
    std::unique_ptr<CHTLUnifiedScanner> m_Scanner;          // ç»Ÿä¸€æ‰«æå™¨
    std::unique_ptr<CHTLCodeMerger> m_CodeMerger;           // ä»£ç åˆå¹¶å™¨
    std::unique_ptr<CJMOD::CJMODManager> m_CJMODManager;    // CJMODç®¡ç†å™¨

public:
    /**
     * ç¼–è¯‘æµç¨‹
     */
    bool Compile(const std::string& sourceCode) {
        // æ­¥éª¤1ï¼šç»Ÿä¸€æ‰«æå’Œåˆ‡å‰²
        if (!PerformUnifiedScanning(sourceCode)) {
            return false;
        }
        
        // æ­¥éª¤2ï¼šæŒ‰ç±»å‹åˆ†ç»„ç‰‡æ®µ
        GroupFragmentsByType();
        
        // æ­¥éª¤3ï¼šCJMODé¢„å¤„ç†
        if (!PreprocessWithCJMOD()) {
            return false;
        }
        
        // æ­¥éª¤4ï¼šåˆ†å‘ç»™ä¸“é—¨ç¼–è¯‘å™¨
        if (!DispatchToSpecializedCompilers()) {
            return false;
        }
        
        // æ­¥éª¤5ï¼šåˆå¹¶ç¼–è¯‘ç»“æœ
        if (!MergeCompilationResults()) {
            return false;
        }
        
        return true;
    }

private:
    /**
     * ç»Ÿä¸€æ‰«æè¿‡ç¨‹
     */
    bool PerformUnifiedScanning(const std::string& sourceCode) {
        m_Scanner->SetSourceCode(sourceCode);
        
        // ç¬¬ä¸€éï¼šè¯­æ³•ç»“æ„åˆ†æ
        auto syntaxStructure = m_Scanner->AnalyzeSyntaxStructure();
        
        // ç¬¬äºŒéï¼šæ™ºèƒ½åˆ‡å‰²
        auto fragments = m_Scanner->PerformIntelligentSlicing(syntaxStructure);
        
        // ç¬¬ä¸‰éï¼šç±»å‹è¯†åˆ«å’Œåˆ†ç±»
        for (auto& fragment : fragments) {
            fragment.Type = m_Scanner->IdentifyFragmentType(fragment);
            fragment.Priority = m_Scanner->CalculateProcessingPriority(fragment);
        }
        
        m_Fragments = std::move(fragments);
        return true;
    }
    
    /**
     * CJMODé¢„å¤„ç†
     */
    bool PreprocessWithCJMOD() {
        if (!m_CJMODManager) return true;
        
        for (size_t i = 0; i < m_Fragments.size(); ++i) {
            auto& fragment = m_Fragments[i];
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦CJMODå¤„ç†
            if (fragment.Type == FragmentType::CHTL_JS_FRAGMENT ||
                fragment.Type == FragmentType::MIXED_FRAGMENT) {
                
                // ä½¿ç”¨CJMODå¤„ç†ç‰‡æ®µ
                std::string processed = m_CJMODManager->ProcessCodeFragment(
                    fragment.Content, i
                );
                
                // æ›´æ–°ç‰‡æ®µå†…å®¹
                fragment.Content = processed;
                fragment.IsProcessedByCJMOD = true;
            }
        }
        
        return true;
    }
};
```

---

## ğŸ” æ™ºèƒ½è¯†åˆ«ç®—æ³•

### ğŸ¯ è¯­è¨€è¯†åˆ«å¼•æ“

```cpp
/**
 * å¤šè¯­è¨€è¯†åˆ«å¼•æ“
 */
class LanguageIdentificationEngine {
private:
    // è¯­è¨€ç‰¹å¾æ¨¡å¼
    struct LanguagePattern {
        std::vector<std::regex> StartPatterns;     // å¼€å§‹æ¨¡å¼
        std::vector<std::regex> EndPatterns;       // ç»“æŸæ¨¡å¼
        std::vector<std::regex> KeywordPatterns;   // å…³é”®å­—æ¨¡å¼
        std::vector<std::regex> StructurePatterns; // ç»“æ„æ¨¡å¼
        double ConfidenceThreshold = 0.7;         // ç½®ä¿¡åº¦é˜ˆå€¼
    };
    
    std::unordered_map<FragmentType, LanguagePattern> m_Patterns;

public:
    /**
     * åˆå§‹åŒ–è¯­è¨€æ¨¡å¼
     */
    void InitializePatterns() {
        // CHTLæ¨¡å¼
        m_Patterns[FragmentType::CHTL_FRAGMENT] = {
            .StartPatterns = {
                std::regex(R"(\[Template\])"),
                std::regex(R"(\[Custom\])"),
                std::regex(R"(\[Configuration\])"),
                std::regex(R"(\[Namespace\])"),
                std::regex(R"(\[Import\])"),
                std::regex(R"(^\s*\w+\s*\{)")  // HTMLå…ƒç´ 
            },
            .KeywordPatterns = {
                std::regex(R"(\buse\s*=)"),
                std::regex(R"(\binherit\s*=)"),
                std::regex(R"(\bexcept\b)"),
                std::regex(R"(\btext\s*\{)")
            }
        };
        
        // CHTL JSæ¨¡å¼
        m_Patterns[FragmentType::CHTL_JS_FRAGMENT] = {
            .StartPatterns = {
                std::regex(R"(\blisten\s*\{)"),
                std::regex(R"(\bdelegate\s*\{)"),
                std::regex(R"(\banimate\s*\{)"),
                std::regex(R"(\bvir\s+\w+\s*=)"),
                std::regex(R"(\bmodule\s*\{)"),
                std::regex(R"(\butil\.\w+)")
            },
            .KeywordPatterns = {
                std::regex(R"(\bprintMylove\b)"),
                std::regex(R"(\biNeverAway\b)"),
                std::regex(R"(\{{.*\}})"),  // å¢å¼ºé€‰æ‹©å™¨
                std::regex(R"(->)"),        // -> æ“ä½œç¬¦
                std::regex(R"(&->)")        // &-> æ“ä½œç¬¦
            }
        };
        
        // CSSæ¨¡å¼
        m_Patterns[FragmentType::CSS_FRAGMENT] = {
            .StartPatterns = {
                std::regex(R"(^\s*\.[a-zA-Z][\w-]*\s*\{)"),  // CSSç±»é€‰æ‹©å™¨
                std::regex(R"(^\s*#[a-zA-Z][\w-]*\s*\{)"),   // CSS IDé€‰æ‹©å™¨
                std::regex(R"(^\s*[a-zA-Z][\w-]*\s*\{)"),    // CSSå…ƒç´ é€‰æ‹©å™¨
                std::regex(R"(@media\s*\()")                 // CSSåª’ä½“æŸ¥è¯¢
            }
        };
        
        // JavaScriptæ¨¡å¼
        m_Patterns[FragmentType::JAVASCRIPT_FRAGMENT] = {
            .StartPatterns = {
                std::regex(R"(\bfunction\s+\w+)"),
                std::regex(R"(\bclass\s+\w+)"),
                std::regex(R"(\bconst\s+\w+\s*=)"),
                std::regex(R"(\blet\s+\w+\s*=)"),
                std::regex(R"(\bvar\s+\w+\s*=)")
            }
        };
    }
    
    /**
     * è¯†åˆ«ç‰‡æ®µç±»å‹
     * @param fragment ä»£ç ç‰‡æ®µ
     * @return ç‰‡æ®µç±»å‹å’Œç½®ä¿¡åº¦
     */
    std::pair<FragmentType, double> IdentifyFragmentType(const CodeFragment& fragment) {
        std::vector<std::pair<FragmentType, double>> scores;
        
        for (const auto& [type, pattern] : m_Patterns) {
            double confidence = CalculateConfidence(fragment.Content, pattern);
            scores.emplace_back(type, confidence);
        }
        
        // æŒ‰ç½®ä¿¡åº¦æ’åº
        std::sort(scores.begin(), scores.end(), 
                 [](const auto& a, const auto& b) { return a.second > b.second; });
        
        if (!scores.empty() && scores[0].second >= m_Patterns[scores[0].first].ConfidenceThreshold) {
            return scores[0];
        }
        
        return {FragmentType::UNKNOWN, 0.0};
    }

private:
    /**
     * è®¡ç®—ç½®ä¿¡åº¦
     */
    double CalculateConfidence(const std::string& content, const LanguagePattern& pattern) {
        double score = 0.0;
        int totalChecks = 0;
        
        // æ£€æŸ¥å¼€å§‹æ¨¡å¼
        for (const auto& startPattern : pattern.StartPatterns) {
            totalChecks++;
            if (std::regex_search(content, startPattern)) {
                score += 0.4;  // å¼€å§‹æ¨¡å¼æƒé‡40%
            }
        }
        
        // æ£€æŸ¥å…³é”®å­—æ¨¡å¼
        for (const auto& keywordPattern : pattern.KeywordPatterns) {
            totalChecks++;
            if (std::regex_search(content, keywordPattern)) {
                score += 0.3;  // å…³é”®å­—æƒé‡30%
            }
        }
        
        // æ£€æŸ¥ç»“æ„æ¨¡å¼
        for (const auto& structurePattern : pattern.StructurePatterns) {
            totalChecks++;
            if (std::regex_search(content, structurePattern)) {
                score += 0.3;  // ç»“æ„æƒé‡30%
            }
        }
        
        return totalChecks > 0 ? score / totalChecks : 0.0;
    }
};
```

---

## ğŸª ç‰‡æ®µç®¡ç†ç³»ç»Ÿ

### ğŸ“Š ç‰‡æ®µåˆ†ç±»å’Œä¼˜å…ˆçº§

```cpp
/**
 * ä»£ç ç‰‡æ®µ
 */
struct CodeFragment {
    FragmentType Type;                    // ç‰‡æ®µç±»å‹
    std::string Content;                  // ç‰‡æ®µå†…å®¹
    size_t StartPosition;                 // å¼€å§‹ä½ç½®
    size_t EndPosition;                   // ç»“æŸä½ç½®
    int Priority;                         // å¤„ç†ä¼˜å…ˆçº§
    int NestingLevel;                     // åµŒå¥—å±‚çº§
    bool IsProcessedByCJMOD;             // æ˜¯å¦å·²è¢«CJMODå¤„ç†
    std::vector<std::string> Dependencies; // ä¾èµ–å…³ç³»
    std::unordered_map<std::string, std::string> Metadata; // å…ƒæ•°æ®
    
    // ç‰‡æ®µè´¨é‡æŒ‡æ ‡
    double SyntaxComplexity;              // è¯­æ³•å¤æ‚åº¦
    double ProcessingDifficulty;          // å¤„ç†éš¾åº¦
    size_t EstimatedProcessingTime;       // é¢„ä¼°å¤„ç†æ—¶é—´
};

/**
 * ç‰‡æ®µä¼˜å…ˆçº§è®¡ç®—å™¨
 */
class FragmentPriorityCalculator {
public:
    /**
     * è®¡ç®—å¤„ç†ä¼˜å…ˆçº§
     * @param fragment ä»£ç ç‰‡æ®µ
     * @return ä¼˜å…ˆçº§ (1-10, 10æœ€é«˜)
     */
    int CalculatePriority(const CodeFragment& fragment) {
        int priority = 5; // åŸºç¡€ä¼˜å…ˆçº§
        
        // æ ¹æ®ç±»å‹è°ƒæ•´ä¼˜å…ˆçº§
        switch (fragment.Type) {
            case FragmentType::CHTL_TEMPLATE:
                priority = 9; // æ¨¡æ¿æœ€é«˜ä¼˜å…ˆçº§
                break;
            case FragmentType::CHTL_CUSTOM:
                priority = 8; // è‡ªå®šä¹‰æ¬¡é«˜
                break;
            case FragmentType::CHTL_ELEMENT:
                priority = 7; // å…ƒç´ ä¸­ç­‰åé«˜
                break;
            case FragmentType::CHTLJS_LISTEN:
            case FragmentType::CHTLJS_DELEGATE:
                priority = 6; // CHTL JSåŠŸèƒ½ä¸­ç­‰
                break;
            case FragmentType::CSS_FRAGMENT:
                priority = 4; // CSSè¾ƒä½
                break;
            case FragmentType::JAVASCRIPT_FRAGMENT:
                priority = 3; // JSæœ€ä½
                break;
        }
        
        // æ ¹æ®ä¾èµ–å…³ç³»è°ƒæ•´
        if (!fragment.Dependencies.empty()) {
            priority += 2; // æœ‰ä¾èµ–çš„ä¼˜å…ˆå¤„ç†
        }
        
        // æ ¹æ®åµŒå¥—å±‚çº§è°ƒæ•´
        if (fragment.NestingLevel > 3) {
            priority += 1; // æ·±åº¦åµŒå¥—ä¼˜å…ˆå¤„ç†
        }
        
        // æ ¹æ®å¤æ‚åº¦è°ƒæ•´
        if (fragment.SyntaxComplexity > 0.8) {
            priority += 1; // å¤æ‚è¯­æ³•ä¼˜å…ˆå¤„ç†
        }
        
        return std::clamp(priority, 1, 10);
    }
};
```

### ğŸ”„ ä¾èµ–å…³ç³»åˆ†æ

```cpp
/**
 * ä¾èµ–å…³ç³»åˆ†æå™¨
 */
class DependencyAnalyzer {
public:
    /**
     * åˆ†æç‰‡æ®µä¾èµ–å…³ç³»
     * @param fragments æ‰€æœ‰ç‰‡æ®µ
     * @return ä¾èµ–å…³ç³»å›¾
     */
    DependencyGraph AnalyzeDependencies(const std::vector<CodeFragment>& fragments) {
        DependencyGraph graph;
        
        for (size_t i = 0; i < fragments.size(); ++i) {
            const auto& fragment = fragments[i];
            
            // åˆ†ææ¨¡æ¿ä¾èµ–
            if (fragment.Type == FragmentType::CHTL_CUSTOM) {
                auto templateDeps = ExtractTemplateDependencies(fragment.Content);
                for (const auto& dep : templateDeps) {
                    graph.AddDependency(i, FindTemplateFragment(fragments, dep));
                }
            }
            
            // åˆ†æå¯¼å…¥ä¾èµ–
            auto importDeps = ExtractImportDependencies(fragment.Content);
            for (const auto& dep : importDeps) {
                auto depFragmentIndex = FindImportedFragment(fragments, dep);
                if (depFragmentIndex != -1) {
                    graph.AddDependency(i, depFragmentIndex);
                }
            }
            
            // åˆ†æCJMODä¾èµ–
            if (fragment.Type == FragmentType::CHTL_JS_FRAGMENT) {
                auto cjmodDeps = ExtractCJMODDependencies(fragment.Content);
                for (const auto& dep : cjmodDeps) {
                    graph.AddCJMODDependency(i, dep);
                }
            }
        }
        
        return graph;
    }
    
    /**
     * æ‹“æ‰‘æ’åº
     * @param graph ä¾èµ–å…³ç³»å›¾
     * @return æ’åºåçš„å¤„ç†é¡ºåº
     */
    std::vector<size_t> TopologicalSort(const DependencyGraph& graph) {
        std::vector<size_t> result;
        std::vector<int> inDegree(graph.GetNodeCount(), 0);
        std::queue<size_t> zeroInDegreeQueue;
        
        // è®¡ç®—å…¥åº¦
        for (const auto& [from, to] : graph.GetEdges()) {
            inDegree[to]++;
        }
        
        // æ‰¾åˆ°å…¥åº¦ä¸º0çš„èŠ‚ç‚¹
        for (size_t i = 0; i < inDegree.size(); ++i) {
            if (inDegree[i] == 0) {
                zeroInDegreeQueue.push(i);
            }
        }
        
        // Kahnç®—æ³•æ‹“æ‰‘æ’åº
        while (!zeroInDegreeQueue.empty()) {
            size_t current = zeroInDegreeQueue.front();
            zeroInDegreeQueue.pop();
            result.push_back(current);
            
            for (size_t neighbor : graph.GetNeighbors(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    zeroInDegreeQueue.push(neighbor);
                }
            }
        }
        
        return result;
    }
};
```

---

## ğŸ”§ CJMODé›†æˆæ¶æ„

### ğŸŒŸ CJMODå¤„ç†æµç¨‹

```cpp
/**
 * CJMODé›†æˆå¤„ç†å™¨
 */
class CJMODIntegrationProcessor {
public:
    /**
     * å¤„ç†CJMODç‰‡æ®µ
     * @param fragment åŸå§‹ç‰‡æ®µ
     * @param fragmentIndex ç‰‡æ®µç´¢å¼•
     * @return å¤„ç†åçš„ç‰‡æ®µ
     */
    std::string ProcessCJMODFragment(const CodeFragment& fragment, size_t fragmentIndex) {
        std::string processedContent = fragment.Content;
        
        // æ­¥éª¤1ï¼šè¯­æ³•åˆ†æ
        auto syntaxResult = CJMOD::Syntax::analyzeCode(processedContent);
        LogCJMODStep("è¯­æ³•åˆ†æ", syntaxResult.Type);
        
        // æ­¥éª¤2ï¼šå ä½ç¬¦æ‰«æ
        auto placeholders = CJMOD::CJMODScanner::scanPlaceholders(processedContent);
        LogCJMODStep("å ä½ç¬¦æ‰«æ", std::to_string(placeholders.size()) + " ä¸ª");
        
        // æ­¥éª¤3ï¼šæ£€æµ‹CHTL JSå‡½æ•°
        if (ContainsCHTLJSFunction(processedContent)) {
            processedContent = ProcessCHTLJSFunctions(processedContent);
            LogCJMODStep("CHTL JSå‡½æ•°å¤„ç†", "å®Œæˆ");
        }
        
        // æ­¥éª¤4ï¼šåº”ç”¨CJMODæ‰©å±•
        if (ContainsCJMODExtensions(processedContent)) {
            processedContent = ApplyCJMODExtensions(processedContent);
            LogCJMODStep("CJMODæ‰©å±•åº”ç”¨", "å®Œæˆ");
        }
        
        // æ­¥éª¤5ï¼šç”Ÿæˆæœ€ç»ˆä»£ç 
        std::string finalCode = CJMOD::CJMODGenerator::exportResult(processedContent);
        LogCJMODStep("ä»£ç ç”Ÿæˆ", std::to_string(finalCode.length()) + " å­—ç¬¦");
        
        // æ­¥éª¤6ï¼šæ›´æ–°æ‰«æå™¨
        UpdateScannerFragment(fragmentIndex, finalCode);
        
        return finalCode;
    }

private:
    /**
     * æ£€æµ‹CHTL JSå‡½æ•°
     */
    bool ContainsCHTLJSFunction(const std::string& code) {
        static const std::vector<std::regex> chtljsFunctions = {
            std::regex(R"(\blisten\s*\{)"),
            std::regex(R"(\bdelegate\s*\{)"),
            std::regex(R"(\banimate\s*\{)"),
            std::regex(R"(\bvir\s+\w+)")
        };
        
        for (const auto& pattern : chtljsFunctions) {
            if (std::regex_search(code, pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * å¤„ç†CHTL JSå‡½æ•°
     */
    std::string ProcessCHTLJSFunctions(const std::string& code) {
        std::string processed = code;
        
        // å¤„ç†listenå‡½æ•°
        processed = ProcessListenFunctions(processed);
        
        // å¤„ç†delegateå‡½æ•°
        processed = ProcessDelegateFunctions(processed);
        
        // å¤„ç†animateå‡½æ•°
        processed = ProcessAnimateFunctions(processed);
        
        // å¤„ç†virå¯¹è±¡
        processed = ProcessVirObjects(processed);
        
        return processed;
    }
    
    /**
     * å¤„ç†listenå‡½æ•°
     */
    std::string ProcessListenFunctions(const std::string& code) {
        std::regex listenPattern(R"(listen\s*\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\})");
        std::smatch match;
        std::string result = code;
        
        while (std::regex_search(result, match, listenPattern)) {
            std::string listenContent = match[1].str();
            
            // åˆ›å»ºCHTL JSå‡½æ•°
            auto functionInfo = CJMOD::CJMODFunctionGenerator::CreateCHTLJSFunction(
                "listen",
                "generatedListener_" + std::to_string(rand()),
                listenContent
            );
            
            // ç”ŸæˆåŒ…è£…å™¨
            std::string wrapper = CJMOD::CJMODFunctionGenerator::generateFunctionWrapper(functionInfo);
            
            // æ›¿æ¢åŸå§‹ä»£ç 
            result.replace(match.position(), match.length(), wrapper);
        }
        
        return result;
    }
};
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### âš¡ æ‰«ææ€§èƒ½ä¼˜åŒ–

```cpp
/**
 * æ‰«ææ€§èƒ½ä¼˜åŒ–å™¨
 */
class ScanningPerformanceOptimizer {
private:
    // ç¼“å­˜ç³»ç»Ÿ
    std::unordered_map<std::string, std::vector<CodeFragment>> m_FragmentCache;
    std::unordered_map<std::string, SyntaxStructure> m_SyntaxCache;
    
    // æ€§èƒ½æŒ‡æ ‡
    struct PerformanceMetrics {
        std::chrono::milliseconds ScanningTime;
        std::chrono::milliseconds AnalysisTime;
        std::chrono::milliseconds CJMODProcessingTime;
        size_t MemoryUsage;
        size_t CacheHitRate;
    };

public:
    /**
     * ä¼˜åŒ–æ‰«æè¿‡ç¨‹
     */
    std::vector<CodeFragment> OptimizedScan(const std::string& sourceCode) {
        auto startTime = std::chrono::high_resolution_clock::now();
        
        // 1. æ£€æŸ¥ç¼“å­˜
        std::string cacheKey = GenerateCacheKey(sourceCode);
        if (m_FragmentCache.count(cacheKey)) {
            m_Metrics.CacheHitRate++;
            return m_FragmentCache[cacheKey];
        }
        
        // 2. å¹¶è¡Œæ‰«æ
        auto fragments = PerformParallelScanning(sourceCode);
        
        // 3. ç¼“å­˜ç»“æœ
        m_FragmentCache[cacheKey] = fragments;
        
        // 4. æ›´æ–°æ€§èƒ½æŒ‡æ ‡
        auto endTime = std::chrono::high_resolution_clock::now();
        m_Metrics.ScanningTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        
        return fragments;
    }

private:
    /**
     * å¹¶è¡Œæ‰«æ
     */
    std::vector<CodeFragment> PerformParallelScanning(const std::string& sourceCode) {
        const size_t numThreads = std::thread::hardware_concurrency();
        const size_t chunkSize = sourceCode.length() / numThreads;
        
        std::vector<std::future<std::vector<CodeFragment>>> futures;
        std::vector<CodeFragment> allFragments;
        
        // åˆ†å—å¹¶è¡Œå¤„ç†
        for (size_t i = 0; i < numThreads; ++i) {
            size_t startPos = i * chunkSize;
            size_t endPos = (i == numThreads - 1) ? sourceCode.length() : (i + 1) * chunkSize;
            
            std::string chunk = sourceCode.substr(startPos, endPos - startPos);
            
            futures.push_back(std::async(std::launch::async, [this, chunk, startPos]() {
                return this->ScanChunk(chunk, startPos);
            }));
        }
        
        // æ”¶é›†ç»“æœ
        for (auto& future : futures) {
            auto chunkFragments = future.get();
            allFragments.insert(allFragments.end(), chunkFragments.begin(), chunkFragments.end());
        }
        
        // åˆå¹¶é‡å ç‰‡æ®µ
        return MergeOverlappingFragments(allFragments);
    }
};
```

### ğŸ§  æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ

```cpp
/**
 * æ™ºèƒ½ç¼“å­˜ç®¡ç†å™¨
 */
class IntelligentCacheManager {
private:
    // ç¼“å­˜é…ç½®
    struct CacheConfig {
        size_t MaxCacheSize = 1000;          // æœ€å¤§ç¼“å­˜æ¡ç›®
        std::chrono::minutes CacheTTL{30};    // ç¼“å­˜ç”Ÿå­˜æ—¶é—´
        double CacheHitThreshold = 0.8;      // ç¼“å­˜å‘½ä¸­é˜ˆå€¼
        bool EnableIntelligentEviction = true; // æ™ºèƒ½æ·˜æ±°
    };
    
    // ç¼“å­˜æ¡ç›®
    struct CacheEntry {
        std::vector<CodeFragment> Fragments;
        std::chrono::steady_clock::time_point CreationTime;
        size_t AccessCount;
        double SimilarityScore;
    };
    
    std::unordered_map<std::string, CacheEntry> m_Cache;
    CacheConfig m_Config;

public:
    /**
     * æ™ºèƒ½ç¼“å­˜æŸ¥æ‰¾
     * @param sourceCode æºä»£ç 
     * @return ç¼“å­˜çš„ç‰‡æ®µï¼ˆå¦‚æœå­˜åœ¨ï¼‰
     */
    std::optional<std::vector<CodeFragment>> SmartLookup(const std::string& sourceCode) {
        std::string exactKey = GenerateExactKey(sourceCode);
        
        // 1. ç²¾ç¡®åŒ¹é…
        if (m_Cache.count(exactKey)) {
            auto& entry = m_Cache[exactKey];
            entry.AccessCount++;
            return entry.Fragments;
        }
        
        // 2. ç›¸ä¼¼æ€§åŒ¹é…
        if (m_Config.EnableIntelligentEviction) {
            auto similarEntry = FindSimilarEntry(sourceCode);
            if (similarEntry.has_value() && 
                similarEntry->SimilarityScore >= m_Config.CacheHitThreshold) {
                
                // åŸºäºç›¸ä¼¼ä»£ç è°ƒæ•´ç‰‡æ®µ
                return AdaptFragmentsForSimilarCode(similarEntry->Fragments, sourceCode);
            }
        }
        
        return std::nullopt;
    }
    
    /**
     * æ™ºèƒ½ç¼“å­˜å­˜å‚¨
     */
    void SmartStore(const std::string& sourceCode, const std::vector<CodeFragment>& fragments) {
        // æ£€æŸ¥ç¼“å­˜å¤§å°
        if (m_Cache.size() >= m_Config.MaxCacheSize) {
            PerformIntelligentEviction();
        }
        
        std::string key = GenerateExactKey(sourceCode);
        CacheEntry entry;
        entry.Fragments = fragments;
        entry.CreationTime = std::chrono::steady_clock::now();
        entry.AccessCount = 1;
        entry.SimilarityScore = 1.0;
        
        m_Cache[key] = std::move(entry);
    }

private:
    /**
     * æ™ºèƒ½æ·˜æ±°ç­–ç•¥
     */
    void PerformIntelligentEviction() {
        auto now = std::chrono::steady_clock::now();
        std::vector<std::string> keysToRemove;
        
        for (const auto& [key, entry] : m_Cache) {
            // æ£€æŸ¥TTL
            if (now - entry.CreationTime > m_Config.CacheTTL) {
                keysToRemove.push_back(key);
                continue;
            }
            
            // æ£€æŸ¥è®¿é—®é¢‘ç‡
            if (entry.AccessCount < 2) {
                keysToRemove.push_back(key);
            }
        }
        
        // ç§»é™¤è¿‡æœŸæ¡ç›®
        for (const auto& key : keysToRemove) {
            m_Cache.erase(key);
        }
        
        // å¦‚æœè¿˜éœ€è¦ç©ºé—´ï¼Œç§»é™¤æœ€å°‘ä½¿ç”¨çš„æ¡ç›®
        if (m_Cache.size() >= m_Config.MaxCacheSize) {
            auto lruKey = FindLeastRecentlyUsed();
            m_Cache.erase(lruKey);
        }
    }
};
```

---

## ğŸ“Š ç›‘æ§å’Œè°ƒè¯•

### ğŸ” æ‰«æå™¨ç›‘æ§

```cpp
/**
 * æ‰«æå™¨æ€§èƒ½ç›‘æ§
 */
class ScannerMonitor {
private:
    struct ScanningMetrics {
        size_t TotalFragments = 0;
        size_t CHTLFragments = 0;
        size_t CHTLJSFragments = 0;
        size_t CSSFragments = 0;
        size_t JSFragments = 0;
        size_t UnknownFragments = 0;
        
        std::chrono::milliseconds TotalScanTime{0};
        std::chrono::milliseconds AverageScanTime{0};
        size_t TotalBytesProcessed = 0;
        double ScanningSpeed = 0.0;  // bytes/ms
        
        size_t CacheHits = 0;
        size_t CacheMisses = 0;
        double CacheHitRate = 0.0;
    };

public:
    /**
     * å¼€å§‹ç›‘æ§æ‰«æè¿‡ç¨‹
     */
    void StartMonitoring(const std::string& sourceCode) {
        m_CurrentMetrics = ScanningMetrics();
        m_StartTime = std::chrono::high_resolution_clock::now();
        m_CurrentMetrics.TotalBytesProcessed = sourceCode.length();
        
        std::cout << "ğŸ” å¼€å§‹æ‰«æç›‘æ§..." << std::endl;
        std::cout << "  æºä»£ç å¤§å°: " << sourceCode.length() << " å­—èŠ‚" << std::endl;
    }
    
    /**
     * è®°å½•ç‰‡æ®µå¤„ç†
     */
    void RecordFragmentProcessed(const CodeFragment& fragment) {
        m_CurrentMetrics.TotalFragments++;
        
        switch (fragment.Type) {
            case FragmentType::CHTL_FRAGMENT:
                m_CurrentMetrics.CHTLFragments++;
                break;
            case FragmentType::CHTL_JS_FRAGMENT:
                m_CurrentMetrics.CHTLJSFragments++;
                break;
            case FragmentType::CSS_FRAGMENT:
                m_CurrentMetrics.CSSFragments++;
                break;
            case FragmentType::JAVASCRIPT_FRAGMENT:
                m_CurrentMetrics.JSFragments++;
                break;
            default:
                m_CurrentMetrics.UnknownFragments++;
                break;
        }
    }
    
    /**
     * å®Œæˆç›‘æ§å¹¶ç”ŸæˆæŠ¥å‘Š
     */
    void FinishMonitoring() {
        auto endTime = std::chrono::high_resolution_clock::now();
        m_CurrentMetrics.TotalScanTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - m_StartTime);
        
        if (m_CurrentMetrics.TotalFragments > 0) {
            m_CurrentMetrics.AverageScanTime = m_CurrentMetrics.TotalScanTime / m_CurrentMetrics.TotalFragments;
        }
        
        m_CurrentMetrics.ScanningSpeed = m_CurrentMetrics.TotalBytesProcessed / 
                                        static_cast<double>(m_CurrentMetrics.TotalScanTime.count());
        
        m_CurrentMetrics.CacheHitRate = m_CurrentMetrics.CacheHits / 
                                       static_cast<double>(m_CurrentMetrics.CacheHits + m_CurrentMetrics.CacheMisses);
        
        GeneratePerformanceReport();
    }

private:
    /**
     * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
     */
    void GeneratePerformanceReport() {
        std::cout << std::endl;
        std::cout << "ğŸ“Š æ‰«æå™¨æ€§èƒ½æŠ¥å‘Š" << std::endl;
        std::cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << std::endl;
        std::cout << "æ€»ç‰‡æ®µæ•°: " << m_CurrentMetrics.TotalFragments << std::endl;
        std::cout << "  â”œâ”€ CHTLç‰‡æ®µ: " << m_CurrentMetrics.CHTLFragments << std::endl;
        std::cout << "  â”œâ”€ CHTL JSç‰‡æ®µ: " << m_CurrentMetrics.CHTLJSFragments << std::endl;
        std::cout << "  â”œâ”€ CSSç‰‡æ®µ: " << m_CurrentMetrics.CSSFragments << std::endl;
        std::cout << "  â”œâ”€ JavaScriptç‰‡æ®µ: " << m_CurrentMetrics.JSFragments << std::endl;
        std::cout << "  â””â”€ æœªçŸ¥ç‰‡æ®µ: " << m_CurrentMetrics.UnknownFragments << std::endl;
        std::cout << std::endl;
        std::cout << "æ€§èƒ½æŒ‡æ ‡:" << std::endl;
        std::cout << "  æ€»æ‰«ææ—¶é—´: " << m_CurrentMetrics.TotalScanTime.count() << "ms" << std::endl;
        std::cout << "  å¹³å‡ç‰‡æ®µæ—¶é—´: " << m_CurrentMetrics.AverageScanTime.count() << "ms" << std::endl;
        std::cout << "  æ‰«æé€Ÿåº¦: " << m_CurrentMetrics.ScanningSpeed << " å­—èŠ‚/ms" << std::endl;
        std::cout << "  ç¼“å­˜å‘½ä¸­ç‡: " << (m_CurrentMetrics.CacheHitRate * 100) << "%" << std::endl;
        std::cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << std::endl;
    }
};
```

---

## ğŸ¯ æ‰©å±•æ€§è®¾è®¡

### ğŸ”Œ æ–°è¯­è¨€æ”¯æŒ

```cpp
/**
 * è¯­è¨€æ‰©å±•æ¥å£
 */
class LanguageExtension {
public:
    virtual ~LanguageExtension() = default;
    
    /**
     * è¯­è¨€è¯†åˆ«
     * @param code ä»£ç ç‰‡æ®µ
     * @return æ˜¯å¦åŒ¹é…æ­¤è¯­è¨€
     */
    virtual bool CanHandle(const std::string& code) = 0;
    
    /**
     * ç‰‡æ®µå¤„ç†
     * @param fragment ä»£ç ç‰‡æ®µ
     * @return å¤„ç†åçš„ç‰‡æ®µ
     */
    virtual CodeFragment ProcessFragment(const CodeFragment& fragment) = 0;
    
    /**
     * è·å–è¯­è¨€ä¿¡æ¯
     */
    virtual LanguageInfo GetLanguageInfo() = 0;
};

/**
 * TypeScriptæ‰©å±•ç¤ºä¾‹
 */
class TypeScriptExtension : public LanguageExtension {
public:
    bool CanHandle(const std::string& code) override {
        // TypeScriptç‰¹å¾æ£€æµ‹
        static const std::vector<std::regex> tsPatterns = {
            std::regex(R"(\binterface\s+\w+)"),
            std::regex(R"(\btype\s+\w+\s*=)"),
            std::regex(R"(:\s*\w+(\[\])?(\s*\|)?)"),  // ç±»å‹æ³¨è§£
            std::regex(R"(\bpublic\s+\w+)"),
            std::regex(R"(\bprivate\s+\w+)")
        };
        
        for (const auto& pattern : tsPatterns) {
            if (std::regex_search(code, pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    CodeFragment ProcessFragment(const CodeFragment& fragment) override {
        CodeFragment processed = fragment;
        processed.Type = FragmentType::TYPESCRIPT_FRAGMENT;
        
        // TypeScriptç‰¹æ®Šå¤„ç†é€»è¾‘
        processed.Content = ProcessTypeScriptCode(fragment.Content);
        
        return processed;
    }
    
    LanguageInfo GetLanguageInfo() override {
        return {
            .Name = "TypeScript",
            .Version = "4.9",
            .FileExtensions = {".ts", ".tsx"},
            .MimeType = "application/typescript"
        };
    }
};

/**
 * æ‰©å±•ç®¡ç†å™¨
 */
class LanguageExtensionManager {
private:
    std::vector<std::unique_ptr<LanguageExtension>> m_Extensions;

public:
    /**
     * æ³¨å†Œè¯­è¨€æ‰©å±•
     */
    void RegisterExtension(std::unique_ptr<LanguageExtension> extension) {
        m_Extensions.push_back(std::move(extension));
    }
    
    /**
     * æŸ¥æ‰¾åˆé€‚çš„æ‰©å±•
     */
    LanguageExtension* FindExtensionForCode(const std::string& code) {
        for (auto& extension : m_Extensions) {
            if (extension->CanHandle(code)) {
                return extension.get();
            }
        }
        return nullptr;
    }
};
```

---

## ğŸ› ï¸ è°ƒè¯•å·¥å…·

### ğŸ” æ‰«æå™¨è°ƒè¯•å™¨

```cpp
/**
 * æ‰«æå™¨è°ƒè¯•å·¥å…·
 */
class ScannerDebugger {
public:
    /**
     * å¯ç”¨è¯¦ç»†è°ƒè¯•
     */
    void EnableVerboseDebugging(bool enable) {
        m_VerboseMode = enable;
        if (enable) {
            std::cout << "ğŸ” æ‰«æå™¨è¯¦ç»†è°ƒè¯•æ¨¡å¼å·²å¯ç”¨" << std::endl;
        }
    }
    
    /**
     * è®°å½•æ‰«ææ­¥éª¤
     */
    void LogScanStep(const std::string& step, const std::string& details) {
        if (m_VerboseMode) {
            std::cout << "  ğŸ”¸ " << step << ": " << details << std::endl;
        }
    }
    
    /**
     * ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š
     */
    void GenerateVisualReport(const std::vector<CodeFragment>& fragments) {
        std::cout << std::endl;
        std::cout << "ğŸ“Š æ‰«æå™¨å¯è§†åŒ–æŠ¥å‘Š" << std::endl;
        std::cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << std::endl;
        
        // ç‰‡æ®µç±»å‹ç»Ÿè®¡
        std::unordered_map<FragmentType, int> typeCount;
        for (const auto& fragment : fragments) {
            typeCount[fragment.Type]++;
        }
        
        std::cout << "ç‰‡æ®µç±»å‹åˆ†å¸ƒ:" << std::endl;
        for (const auto& [type, count] : typeCount) {
            std::cout << "  " << GetFragmentTypeName(type) << ": " << count << " ä¸ª" << std::endl;
        }
        
        std::cout << std::endl;
        
        // ç‰‡æ®µè¯¦ç»†ä¿¡æ¯
        std::cout << "ç‰‡æ®µè¯¦ç»†ä¿¡æ¯:" << std::endl;
        for (size_t i = 0; i < fragments.size() && i < 10; ++i) {  // åªæ˜¾ç¤ºå‰10ä¸ª
            const auto& fragment = fragments[i];
            std::cout << "  [" << i << "] " << GetFragmentTypeName(fragment.Type) 
                      << " (" << fragment.StartPosition << "-" << fragment.EndPosition << ")" << std::endl;
            
            // æ˜¾ç¤ºå†…å®¹é¢„è§ˆ
            std::string preview = fragment.Content.substr(0, 50);
            if (fragment.Content.length() > 50) {
                preview += "...";
            }
            std::cout << "      \"" << preview << "\"" << std::endl;
        }
        
        if (fragments.size() > 10) {
            std::cout << "  ... è¿˜æœ‰ " << (fragments.size() - 10) << " ä¸ªç‰‡æ®µ" << std::endl;
        }
        
        std::cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << std::endl;
    }
};
```

---

## ğŸŠ æ€»ç»“

ç»Ÿä¸€æ‰«æå™¨æ¶æ„æ˜¯CHTLç¼–è¯‘å™¨çš„æ ¸å¿ƒåˆ›æ–°ï¼Œæä¾›äº†ï¼š

- ğŸ”¥ **ç²¾å‡†ä»£ç åˆ‡å‰²** - å¯å˜é•¿åº¦åˆ‡ç‰‡å’Œæœ€å°è¯­æ³•å•å…ƒè¯†åˆ«
- ğŸ”¥ **æ™ºèƒ½ç±»å‹è¯†åˆ«** - å¤šè¯­è¨€æ··åˆä»£ç çš„å‡†ç¡®åˆ†ç±»
- ğŸ”¥ **é«˜æ•ˆå¤„ç†** - å¹¶è¡Œæ‰«æå’Œæ™ºèƒ½ç¼“å­˜
- ğŸ”¥ **CJMODé›†æˆ** - ä¸CJMODç³»ç»Ÿçš„æ·±åº¦é›†æˆ
- ğŸ”¥ **æ‰©å±•æ€§è®¾è®¡** - æ”¯æŒæ–°è¯­è¨€ç±»å‹çš„æ‰©å±•
- ğŸ”¥ **æ€§èƒ½ç›‘æ§** - å®Œæ•´çš„æ€§èƒ½åˆ†æå’Œè°ƒè¯•å·¥å…·

ç»Ÿä¸€æ‰«æå™¨ä½¿å¾—CHTLç¼–è¯‘å™¨èƒ½å¤Ÿå¤„ç†å¤æ‚çš„å¤šè¯­è¨€æ··åˆä»£ç ï¼Œä¸ºåŒè¯­è¨€åˆ†ç¦»æ¶æ„å’Œå››ç¼–è¯‘å™¨åè°ƒç³»ç»Ÿæä¾›äº†åšå®çš„åŸºç¡€ã€‚

**ğŸŒŸ ç»Ÿä¸€æ‰«æå™¨ - CHTLç¼–è¯‘å™¨æ¶æ„çš„æ ¸å¿ƒåˆ›æ–°ï¼**