#pragma once

#include "CHTLBaseNode.h"
#include <unordered_map>
#include <vector>

namespace CHTL {

/**
 * 样式规则结构
 * 存储CSS选择器和属性的映射
 */
struct StyleRule {
    std::string Selector;                               // 选择器（.class、#id、&等）
    std::unordered_map<std::string, std::string> Properties; // CSS属性
    bool IsInlineStyle;                                // 是否为内联样式
    bool IsGlobalStyle;                                // 是否为全局样式
    
    StyleRule() : IsInlineStyle(false), IsGlobalStyle(false) {}
    StyleRule(const std::string& selector) : Selector(selector), IsInlineStyle(false), IsGlobalStyle(false) {}
};

/**
 * CHTL样式节点
 * 表示局部样式块（style{}），支持CHTL样式增强功能
 */
class StyleNode : public CHTLBaseNode {
private:
    std::vector<StyleRule> m_StyleRules;               // 样式规则列表
    std::unordered_map<std::string, std::string> m_InlineProperties; // 内联样式属性
    std::vector<std::string> m_AutoGeneratedSelectors; // 自动生成的选择器
    std::vector<std::string> m_ContextReferences;      // 上下文引用列表（&）
    std::vector<std::string> m_TemplateUsages;         // 模板使用列表
    std::vector<std::string> m_CustomUsages;           // 自定义使用列表
    std::vector<std::string> m_VariableReferences;     // 变量引用列表
    std::vector<std::string> m_DeletedProperties;      // 删除的属性列表
    std::vector<std::string> m_DeletedInherits;        // 删除的继承列表
    
    bool m_HasContextReference;                        // 是否有上下文引用
    bool m_HasAutoSelector;                           // 是否有自动选择器

public:
    /**
     * 构造函数
     * @param line 行号
     * @param column 列号
     */
    StyleNode(size_t line = 0, size_t column = 0);
    
    /**
     * 析构函数
     */
    ~StyleNode() override = default;
    
    // 样式规则管理
    /**
     * 添加样式规则
     * @param rule 样式规则
     */
    void AddStyleRule(const StyleRule& rule);
    
    /**
     * 添加选择器样式
     * @param selector 选择器
     * @param properties CSS属性映射
     */
    void AddSelectorStyle(const std::string& selector, 
                         const std::unordered_map<std::string, std::string>& properties);
    
    /**
     * 获取所有样式规则
     * @return 样式规则列表
     */
    const std::vector<StyleRule>& GetStyleRules() const { return m_StyleRules; }
    
    /**
     * 获取指定选择器的样式规则
     * @param selector 选择器
     * @return 样式规则指针，如果不存在返回nullptr
     */
    StyleRule* GetStyleRule(const std::string& selector);
    
    // 内联样式管理
    /**
     * 添加内联样式属性
     * @param property 属性名
     * @param value 属性值
     */
    void AddInlineProperty(const std::string& property, const std::string& value);
    
    /**
     * 获取所有内联样式属性
     * @return 内联样式属性映射
     */
    const std::unordered_map<std::string, std::string>& GetInlineProperties() const { return m_InlineProperties; }
    
    /**
     * 检查是否有内联样式
     * @return 是否有内联样式
     */
    bool HasInlineStyle() const { return !m_InlineProperties.empty(); }
    
    // 自动化选择器管理
    /**
     * 添加自动生成的选择器
     * @param selector 选择器
     */
    void AddAutoGeneratedSelector(const std::string& selector);
    
    /**
     * 获取自动生成的选择器列表
     * @return 选择器列表
     */
    const std::vector<std::string>& GetAutoGeneratedSelectors() const { return m_AutoGeneratedSelectors; }
    
    /**
     * 检查是否有自动选择器
     * @return 是否有自动选择器
     */
    bool HasAutoSelector() const { return m_HasAutoSelector; }
    
    // 上下文引用管理
    /**
     * 添加上下文引用
     * @param reference 引用内容
     */
    void AddContextReference(const std::string& reference);
    
    /**
     * 获取上下文引用列表
     * @return 引用列表
     */
    const std::vector<std::string>& GetContextReferences() const { return m_ContextReferences; }
    
    /**
     * 检查是否有上下文引用
     * @return 是否有上下文引用
     */
    bool HasContextReference() const { return m_HasContextReference; }
    
    /**
     * 解析上下文引用
     * @param contextClass 上下文类名
     * @param contextId 上下文ID
     * @return 解析后的选择器
     */
    std::string ResolveContextReference(const std::string& contextClass, const std::string& contextId) const;
    
    // 模板和自定义管理
    /**
     * 添加模板使用
     * @param templateUsage 模板使用
     */
    void AddTemplateUsage(const std::string& templateUsage);
    
    /**
     * 添加自定义使用
     * @param customUsage 自定义使用
     */
    void AddCustomUsage(const std::string& customUsage);
    
    /**
     * 添加变量引用
     * @param variableRef 变量引用
     */
    void AddVariableReference(const std::string& variableRef);
    
    /**
     * 获取模板使用列表
     * @return 模板使用列表
     */
    const std::vector<std::string>& GetTemplateUsages() const { return m_TemplateUsages; }
    
    /**
     * 获取自定义使用列表
     * @return 自定义使用列表
     */
    const std::vector<std::string>& GetCustomUsages() const { return m_CustomUsages; }
    
    /**
     * 获取变量引用列表
     * @return 变量引用列表
     */
    const std::vector<std::string>& GetVariableReferences() const { return m_VariableReferences; }
    
    // 特例化操作管理
    /**
     * 添加删除的属性
     * @param property 属性名
     */
    void AddDeletedProperty(const std::string& property);
    
    /**
     * 添加删除的继承
     * @param inherit 继承名
     */
    void AddDeletedInherit(const std::string& inherit);
    
    /**
     * 获取删除的属性列表
     * @return 属性列表
     */
    const std::vector<std::string>& GetDeletedProperties() const { return m_DeletedProperties; }
    
    /**
     * 获取删除的继承列表
     * @return 继承列表
     */
    const std::vector<std::string>& GetDeletedInherits() const { return m_DeletedInherits; }
    
    // CSS代码生成
    /**
     * 生成内联样式代码
     * @return CSS内联样式字符串
     */
    std::string GenerateInlineCSS() const;
    
    /**
     * 生成全局样式代码
     * @return CSS全局样式字符串
     */
    std::string GenerateGlobalCSS() const;
    
    /**
     * 生成完整的CSS代码
     * @return 完整CSS代码
     */
    std::string GenerateFullCSS() const;
    
    // 解析和处理
    /**
     * 解析样式内容
     * @param styleContent 样式内容字符串
     */
    void ParseStyleContent(const std::string& styleContent);
    
    /**
     * 处理伪类和伪元素
     * @param selector 选择器
     * @param properties 属性
     * @return 处理后的选择器
     */
    std::string ProcessPseudoSelectors(const std::string& selector, 
                                      const std::unordered_map<std::string, std::string>& properties);
    
    // 访问者模式实现
    void Accept(CHTLNodeVisitor* visitor) override;
    
    // 克隆实现
    std::unique_ptr<CHTLBaseNode> Clone() const override;
    
    // 调试输出
    std::string ToString(int indent = 0) const override;

private:
    /**
     * 解析CSS属性
     * @param propertyBlock 属性块
     * @return 属性映射
     */
    std::unordered_map<std::string, std::string> ParseCSSProperties(const std::string& propertyBlock);
    
    /**
     * 验证CSS属性名
     * @param property 属性名
     * @return 是否有效
     */
    bool IsValidCSSProperty(const std::string& property) const;
    
    /**
     * 处理CSS属性值
     * @param value 属性值
     * @return 处理后的值
     */
    std::string ProcessCSSValue(const std::string& value) const;
};

} // namespace CHTL