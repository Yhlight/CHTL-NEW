# 统一扫描器架构说明

## 🏗️ 架构概述

**CHTLUnifiedScanner (统一扫描器)** 是CHTL编译器的核心组件，负责精准的代码切割和片段管理。它采用创新的**可变长度切片技术**和**最小语法单元切割**，实现了对CHTL、CHTL JS、CSS、JavaScript等多种语言的智能识别和分离。

### 🎯 设计目标

- **精准切割** - 准确识别不同语言的代码边界
- **智能分类** - 自动分类代码片段类型
- **高效处理** - 支持大文件和复杂嵌套结构
- **扩展性** - 支持新语言类型的扩展
- **容错性** - 处理语法错误和边界情况

---

## 🔧 核心技术

### 📐 可变长度切片技术

统一扫描器采用动态长度分析，根据语法结构自动调整切片大小：

```cpp
class CHTLUnifiedScanner {
private:
    /**
     * 可变长度切片配置
     */
    struct SliceConfig {
        size_t MinSliceSize = 1;        // 最小切片大小
        size_t MaxSliceSize = 10000;    // 最大切片大小
        size_t DefaultSliceSize = 100;  // 默认切片大小
        bool AdaptiveSlicing = true;    // 自适应切片
        bool ContextAware = true;       // 上下文感知
    };
    
    /**
     * 动态调整切片大小
     * @param context 当前语法上下文
     * @param complexity 代码复杂度
     * @return 推荐的切片大小
     */
    size_t CalculateOptimalSliceSize(const SyntaxContext& context, 
                                   double complexity) {
        size_t baseSize = m_SliceConfig.DefaultSliceSize;
        
        // 根据复杂度调整
        if (complexity > 0.8) {
            baseSize = m_SliceConfig.MinSliceSize;  // 复杂代码小切片
        } else if (complexity < 0.3) {
            baseSize = m_SliceConfig.MaxSliceSize;  // 简单代码大切片
        }
        
        // 根据上下文调整
        if (context.IsNestedStructure) {
            baseSize /= 2;  // 嵌套结构减半
        }
        
        if (context.HasMixedLanguages) {
            baseSize /= 3;  // 混合语言更小切片
        }
        
        return std::clamp(baseSize, 
                         m_SliceConfig.MinSliceSize, 
                         m_SliceConfig.MaxSliceSize);
    }
};
```

### ⚗️ 最小语法单元切割

扫描器能够识别各种语言的最小语法单元，确保切割不会破坏语法结构：

```cpp
/**
 * 语法单元类型
 */
enum class SyntaxUnitType {
    CHTL_ELEMENT,           // CHTL元素
    CHTL_TEMPLATE,          // CHTL模板
    CHTL_CUSTOM,            // CHTL自定义
    CHTL_STYLE_BLOCK,       // CHTL样式块
    CHTL_SCRIPT_BLOCK,      // CHTL脚本块
    CHTLJS_LISTEN,          // CHTL JS监听器
    CHTLJS_DELEGATE,        // CHTL JS委托
    CHTLJS_ANIMATE,         // CHTL JS动画
    CHTLJS_VIR_OBJECT,      // CHTL JS虚拟对象
    CSS_RULE,               // CSS规则
    CSS_SELECTOR,           // CSS选择器
    JS_FUNCTION,            // JavaScript函数
    JS_CLASS,               // JavaScript类
    JS_EXPRESSION,          // JavaScript表达式
    MIXED_FRAGMENT,         // 混合片段
    UNKNOWN                 // 未知类型
};

/**
 * 最小语法单元
 */
struct SyntaxUnit {
    SyntaxUnitType Type;
    size_t StartPosition;
    size_t EndPosition;
    size_t Length;
    std::string Content;
    int NestingLevel;
    std::vector<SyntaxUnit> ChildUnits;
    std::unordered_map<std::string, std::string> Attributes;
};

class SyntaxUnitAnalyzer {
public:
    /**
     * 分析最小语法单元
     * @param code 源代码
     * @param startPos 开始位置
     * @return 语法单元信息
     */
    SyntaxUnit AnalyzeMinimalUnit(const std::string& code, size_t startPos) {
        SyntaxUnit unit;
        unit.StartPosition = startPos;
        
        // 识别语法单元类型
        unit.Type = IdentifySyntaxType(code, startPos);
        
        // 计算单元边界
        auto boundaries = CalculateUnitBoundaries(code, startPos, unit.Type);
        unit.EndPosition = boundaries.EndPos;
        unit.Length = boundaries.Length;
        
        // 提取内容
        unit.Content = code.substr(startPos, unit.Length);
        
        // 分析嵌套结构
        if (HasNestedStructure(unit.Type)) {
            unit.ChildUnits = AnalyzeChildUnits(unit.Content);
            unit.NestingLevel = CalculateNestingLevel(unit.ChildUnits);
        }
        
        // 提取属性
        unit.Attributes = ExtractUnitAttributes(unit.Content, unit.Type);
        
        return unit;
    }

private:
    /**
     * 识别语法类型
     */
    SyntaxUnitType IdentifySyntaxType(const std::string& code, size_t pos) {
        // CHTL语法识别
        if (IsAtCHTLElement(code, pos)) return SyntaxUnitType::CHTL_ELEMENT;
        if (IsAtTemplate(code, pos)) return SyntaxUnitType::CHTL_TEMPLATE;
        if (IsAtCustom(code, pos)) return SyntaxUnitType::CHTL_CUSTOM;
        if (IsAtStyleBlock(code, pos)) return SyntaxUnitType::CHTL_STYLE_BLOCK;
        if (IsAtScriptBlock(code, pos)) return SyntaxUnitType::CHTL_SCRIPT_BLOCK;
        
        // CHTL JS语法识别
        if (IsAtListen(code, pos)) return SyntaxUnitType::CHTLJS_LISTEN;
        if (IsAtDelegate(code, pos)) return SyntaxUnitType::CHTLJS_DELEGATE;
        if (IsAtAnimate(code, pos)) return SyntaxUnitType::CHTLJS_ANIMATE;
        if (IsAtVirObject(code, pos)) return SyntaxUnitType::CHTLJS_VIR_OBJECT;
        
        // CSS语法识别
        if (IsAtCSSRule(code, pos)) return SyntaxUnitType::CSS_RULE;
        
        // JavaScript语法识别
        if (IsAtJSFunction(code, pos)) return SyntaxUnitType::JS_FUNCTION;
        if (IsAtJSClass(code, pos)) return SyntaxUnitType::JS_CLASS;
        
        return SyntaxUnitType::UNKNOWN;
    }
};
```

---

## 🎯 四编译器协调架构

### 🎼 编译器调度系统

```cpp
/**
 * 编译器调度器
 * 协调四个专门编译器的工作
 */
class CompilerDispatcher {
private:
    // 四个专门编译器
    std::unique_ptr<CHTLCompiler> m_CHTLCompiler;           // CHTL编译器
    std::unique_ptr<CHTLJSCompiler> m_CHTLJSCompiler;       // CHTL JS编译器
    std::unique_ptr<CSSCompiler> m_CSSCompiler;             // CSS编译器 (ANTLR)
    std::unique_ptr<JavaScriptCompiler> m_JSCompiler;       // JS编译器 (ANTLR)
    
    // 核心组件
    std::unique_ptr<CHTLUnifiedScanner> m_Scanner;          // 统一扫描器
    std::unique_ptr<CHTLCodeMerger> m_CodeMerger;           // 代码合并器
    std::unique_ptr<CJMOD::CJMODManager> m_CJMODManager;    // CJMOD管理器

public:
    /**
     * 编译流程
     */
    bool Compile(const std::string& sourceCode) {
        // 步骤1：统一扫描和切割
        if (!PerformUnifiedScanning(sourceCode)) {
            return false;
        }
        
        // 步骤2：按类型分组片段
        GroupFragmentsByType();
        
        // 步骤3：CJMOD预处理
        if (!PreprocessWithCJMOD()) {
            return false;
        }
        
        // 步骤4：分发给专门编译器
        if (!DispatchToSpecializedCompilers()) {
            return false;
        }
        
        // 步骤5：合并编译结果
        if (!MergeCompilationResults()) {
            return false;
        }
        
        return true;
    }

private:
    /**
     * 统一扫描过程
     */
    bool PerformUnifiedScanning(const std::string& sourceCode) {
        m_Scanner->SetSourceCode(sourceCode);
        
        // 第一遍：语法结构分析
        auto syntaxStructure = m_Scanner->AnalyzeSyntaxStructure();
        
        // 第二遍：智能切割
        auto fragments = m_Scanner->PerformIntelligentSlicing(syntaxStructure);
        
        // 第三遍：类型识别和分类
        for (auto& fragment : fragments) {
            fragment.Type = m_Scanner->IdentifyFragmentType(fragment);
            fragment.Priority = m_Scanner->CalculateProcessingPriority(fragment);
        }
        
        m_Fragments = std::move(fragments);
        return true;
    }
    
    /**
     * CJMOD预处理
     */
    bool PreprocessWithCJMOD() {
        if (!m_CJMODManager) return true;
        
        for (size_t i = 0; i < m_Fragments.size(); ++i) {
            auto& fragment = m_Fragments[i];
            
            // 检查是否需要CJMOD处理
            if (fragment.Type == FragmentType::CHTL_JS_FRAGMENT ||
                fragment.Type == FragmentType::MIXED_FRAGMENT) {
                
                // 使用CJMOD处理片段
                std::string processed = m_CJMODManager->ProcessCodeFragment(
                    fragment.Content, i
                );
                
                // 更新片段内容
                fragment.Content = processed;
                fragment.IsProcessedByCJMOD = true;
            }
        }
        
        return true;
    }
};
```

---

## 🔍 智能识别算法

### 🎯 语言识别引擎

```cpp
/**
 * 多语言识别引擎
 */
class LanguageIdentificationEngine {
private:
    // 语言特征模式
    struct LanguagePattern {
        std::vector<std::regex> StartPatterns;     // 开始模式
        std::vector<std::regex> EndPatterns;       // 结束模式
        std::vector<std::regex> KeywordPatterns;   // 关键字模式
        std::vector<std::regex> StructurePatterns; // 结构模式
        double ConfidenceThreshold = 0.7;         // 置信度阈值
    };
    
    std::unordered_map<FragmentType, LanguagePattern> m_Patterns;

public:
    /**
     * 初始化语言模式
     */
    void InitializePatterns() {
        // CHTL模式
        m_Patterns[FragmentType::CHTL_FRAGMENT] = {
            .StartPatterns = {
                std::regex(R"(\[Template\])"),
                std::regex(R"(\[Custom\])"),
                std::regex(R"(\[Configuration\])"),
                std::regex(R"(\[Namespace\])"),
                std::regex(R"(\[Import\])"),
                std::regex(R"(^\s*\w+\s*\{)")  // HTML元素
            },
            .KeywordPatterns = {
                std::regex(R"(\buse\s*=)"),
                std::regex(R"(\binherit\s*=)"),
                std::regex(R"(\bexcept\b)"),
                std::regex(R"(\btext\s*\{)")
            }
        };
        
        // CHTL JS模式
        m_Patterns[FragmentType::CHTL_JS_FRAGMENT] = {
            .StartPatterns = {
                std::regex(R"(\blisten\s*\{)"),
                std::regex(R"(\bdelegate\s*\{)"),
                std::regex(R"(\banimate\s*\{)"),
                std::regex(R"(\bvir\s+\w+\s*=)"),
                std::regex(R"(\bmodule\s*\{)"),
                std::regex(R"(\butil\.\w+)")
            },
            .KeywordPatterns = {
                std::regex(R"(\bprintMylove\b)"),
                std::regex(R"(\biNeverAway\b)"),
                std::regex(R"(\{{.*\}})"),  // 增强选择器
                std::regex(R"(->)"),        // -> 操作符
                std::regex(R"(&->)")        // &-> 操作符
            }
        };
        
        // CSS模式
        m_Patterns[FragmentType::CSS_FRAGMENT] = {
            .StartPatterns = {
                std::regex(R"(^\s*\.[a-zA-Z][\w-]*\s*\{)"),  // CSS类选择器
                std::regex(R"(^\s*#[a-zA-Z][\w-]*\s*\{)"),   // CSS ID选择器
                std::regex(R"(^\s*[a-zA-Z][\w-]*\s*\{)"),    // CSS元素选择器
                std::regex(R"(@media\s*\()")                 // CSS媒体查询
            }
        };
        
        // JavaScript模式
        m_Patterns[FragmentType::JAVASCRIPT_FRAGMENT] = {
            .StartPatterns = {
                std::regex(R"(\bfunction\s+\w+)"),
                std::regex(R"(\bclass\s+\w+)"),
                std::regex(R"(\bconst\s+\w+\s*=)"),
                std::regex(R"(\blet\s+\w+\s*=)"),
                std::regex(R"(\bvar\s+\w+\s*=)")
            }
        };
    }
    
    /**
     * 识别片段类型
     * @param fragment 代码片段
     * @return 片段类型和置信度
     */
    std::pair<FragmentType, double> IdentifyFragmentType(const CodeFragment& fragment) {
        std::vector<std::pair<FragmentType, double>> scores;
        
        for (const auto& [type, pattern] : m_Patterns) {
            double confidence = CalculateConfidence(fragment.Content, pattern);
            scores.emplace_back(type, confidence);
        }
        
        // 按置信度排序
        std::sort(scores.begin(), scores.end(), 
                 [](const auto& a, const auto& b) { return a.second > b.second; });
        
        if (!scores.empty() && scores[0].second >= m_Patterns[scores[0].first].ConfidenceThreshold) {
            return scores[0];
        }
        
        return {FragmentType::UNKNOWN, 0.0};
    }

private:
    /**
     * 计算置信度
     */
    double CalculateConfidence(const std::string& content, const LanguagePattern& pattern) {
        double score = 0.0;
        int totalChecks = 0;
        
        // 检查开始模式
        for (const auto& startPattern : pattern.StartPatterns) {
            totalChecks++;
            if (std::regex_search(content, startPattern)) {
                score += 0.4;  // 开始模式权重40%
            }
        }
        
        // 检查关键字模式
        for (const auto& keywordPattern : pattern.KeywordPatterns) {
            totalChecks++;
            if (std::regex_search(content, keywordPattern)) {
                score += 0.3;  // 关键字权重30%
            }
        }
        
        // 检查结构模式
        for (const auto& structurePattern : pattern.StructurePatterns) {
            totalChecks++;
            if (std::regex_search(content, structurePattern)) {
                score += 0.3;  // 结构权重30%
            }
        }
        
        return totalChecks > 0 ? score / totalChecks : 0.0;
    }
};
```

---

## 🎪 片段管理系统

### 📊 片段分类和优先级

```cpp
/**
 * 代码片段
 */
struct CodeFragment {
    FragmentType Type;                    // 片段类型
    std::string Content;                  // 片段内容
    size_t StartPosition;                 // 开始位置
    size_t EndPosition;                   // 结束位置
    int Priority;                         // 处理优先级
    int NestingLevel;                     // 嵌套层级
    bool IsProcessedByCJMOD;             // 是否已被CJMOD处理
    std::vector<std::string> Dependencies; // 依赖关系
    std::unordered_map<std::string, std::string> Metadata; // 元数据
    
    // 片段质量指标
    double SyntaxComplexity;              // 语法复杂度
    double ProcessingDifficulty;          // 处理难度
    size_t EstimatedProcessingTime;       // 预估处理时间
};

/**
 * 片段优先级计算器
 */
class FragmentPriorityCalculator {
public:
    /**
     * 计算处理优先级
     * @param fragment 代码片段
     * @return 优先级 (1-10, 10最高)
     */
    int CalculatePriority(const CodeFragment& fragment) {
        int priority = 5; // 基础优先级
        
        // 根据类型调整优先级
        switch (fragment.Type) {
            case FragmentType::CHTL_TEMPLATE:
                priority = 9; // 模板最高优先级
                break;
            case FragmentType::CHTL_CUSTOM:
                priority = 8; // 自定义次高
                break;
            case FragmentType::CHTL_ELEMENT:
                priority = 7; // 元素中等偏高
                break;
            case FragmentType::CHTLJS_LISTEN:
            case FragmentType::CHTLJS_DELEGATE:
                priority = 6; // CHTL JS功能中等
                break;
            case FragmentType::CSS_FRAGMENT:
                priority = 4; // CSS较低
                break;
            case FragmentType::JAVASCRIPT_FRAGMENT:
                priority = 3; // JS最低
                break;
        }
        
        // 根据依赖关系调整
        if (!fragment.Dependencies.empty()) {
            priority += 2; // 有依赖的优先处理
        }
        
        // 根据嵌套层级调整
        if (fragment.NestingLevel > 3) {
            priority += 1; // 深度嵌套优先处理
        }
        
        // 根据复杂度调整
        if (fragment.SyntaxComplexity > 0.8) {
            priority += 1; // 复杂语法优先处理
        }
        
        return std::clamp(priority, 1, 10);
    }
};
```

### 🔄 依赖关系分析

```cpp
/**
 * 依赖关系分析器
 */
class DependencyAnalyzer {
public:
    /**
     * 分析片段依赖关系
     * @param fragments 所有片段
     * @return 依赖关系图
     */
    DependencyGraph AnalyzeDependencies(const std::vector<CodeFragment>& fragments) {
        DependencyGraph graph;
        
        for (size_t i = 0; i < fragments.size(); ++i) {
            const auto& fragment = fragments[i];
            
            // 分析模板依赖
            if (fragment.Type == FragmentType::CHTL_CUSTOM) {
                auto templateDeps = ExtractTemplateDependencies(fragment.Content);
                for (const auto& dep : templateDeps) {
                    graph.AddDependency(i, FindTemplateFragment(fragments, dep));
                }
            }
            
            // 分析导入依赖
            auto importDeps = ExtractImportDependencies(fragment.Content);
            for (const auto& dep : importDeps) {
                auto depFragmentIndex = FindImportedFragment(fragments, dep);
                if (depFragmentIndex != -1) {
                    graph.AddDependency(i, depFragmentIndex);
                }
            }
            
            // 分析CJMOD依赖
            if (fragment.Type == FragmentType::CHTL_JS_FRAGMENT) {
                auto cjmodDeps = ExtractCJMODDependencies(fragment.Content);
                for (const auto& dep : cjmodDeps) {
                    graph.AddCJMODDependency(i, dep);
                }
            }
        }
        
        return graph;
    }
    
    /**
     * 拓扑排序
     * @param graph 依赖关系图
     * @return 排序后的处理顺序
     */
    std::vector<size_t> TopologicalSort(const DependencyGraph& graph) {
        std::vector<size_t> result;
        std::vector<int> inDegree(graph.GetNodeCount(), 0);
        std::queue<size_t> zeroInDegreeQueue;
        
        // 计算入度
        for (const auto& [from, to] : graph.GetEdges()) {
            inDegree[to]++;
        }
        
        // 找到入度为0的节点
        for (size_t i = 0; i < inDegree.size(); ++i) {
            if (inDegree[i] == 0) {
                zeroInDegreeQueue.push(i);
            }
        }
        
        // Kahn算法拓扑排序
        while (!zeroInDegreeQueue.empty()) {
            size_t current = zeroInDegreeQueue.front();
            zeroInDegreeQueue.pop();
            result.push_back(current);
            
            for (size_t neighbor : graph.GetNeighbors(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    zeroInDegreeQueue.push(neighbor);
                }
            }
        }
        
        return result;
    }
};
```

---

## 🔧 CJMOD集成架构

### 🌟 CJMOD处理流程

```cpp
/**
 * CJMOD集成处理器
 */
class CJMODIntegrationProcessor {
public:
    /**
     * 处理CJMOD片段
     * @param fragment 原始片段
     * @param fragmentIndex 片段索引
     * @return 处理后的片段
     */
    std::string ProcessCJMODFragment(const CodeFragment& fragment, size_t fragmentIndex) {
        std::string processedContent = fragment.Content;
        
        // 步骤1：语法分析
        auto syntaxResult = CJMOD::Syntax::analyzeCode(processedContent);
        LogCJMODStep("语法分析", syntaxResult.Type);
        
        // 步骤2：占位符扫描
        auto placeholders = CJMOD::CJMODScanner::scanPlaceholders(processedContent);
        LogCJMODStep("占位符扫描", std::to_string(placeholders.size()) + " 个");
        
        // 步骤3：检测CHTL JS函数
        if (ContainsCHTLJSFunction(processedContent)) {
            processedContent = ProcessCHTLJSFunctions(processedContent);
            LogCJMODStep("CHTL JS函数处理", "完成");
        }
        
        // 步骤4：应用CJMOD扩展
        if (ContainsCJMODExtensions(processedContent)) {
            processedContent = ApplyCJMODExtensions(processedContent);
            LogCJMODStep("CJMOD扩展应用", "完成");
        }
        
        // 步骤5：生成最终代码
        std::string finalCode = CJMOD::CJMODGenerator::exportResult(processedContent);
        LogCJMODStep("代码生成", std::to_string(finalCode.length()) + " 字符");
        
        // 步骤6：更新扫描器
        UpdateScannerFragment(fragmentIndex, finalCode);
        
        return finalCode;
    }

private:
    /**
     * 检测CHTL JS函数
     */
    bool ContainsCHTLJSFunction(const std::string& code) {
        static const std::vector<std::regex> chtljsFunctions = {
            std::regex(R"(\blisten\s*\{)"),
            std::regex(R"(\bdelegate\s*\{)"),
            std::regex(R"(\banimate\s*\{)"),
            std::regex(R"(\bvir\s+\w+)")
        };
        
        for (const auto& pattern : chtljsFunctions) {
            if (std::regex_search(code, pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 处理CHTL JS函数
     */
    std::string ProcessCHTLJSFunctions(const std::string& code) {
        std::string processed = code;
        
        // 处理listen函数
        processed = ProcessListenFunctions(processed);
        
        // 处理delegate函数
        processed = ProcessDelegateFunctions(processed);
        
        // 处理animate函数
        processed = ProcessAnimateFunctions(processed);
        
        // 处理vir对象
        processed = ProcessVirObjects(processed);
        
        return processed;
    }
    
    /**
     * 处理listen函数
     */
    std::string ProcessListenFunctions(const std::string& code) {
        std::regex listenPattern(R"(listen\s*\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\})");
        std::smatch match;
        std::string result = code;
        
        while (std::regex_search(result, match, listenPattern)) {
            std::string listenContent = match[1].str();
            
            // 创建CHTL JS函数
            auto functionInfo = CJMOD::CJMODFunctionGenerator::CreateCHTLJSFunction(
                "listen",
                "generatedListener_" + std::to_string(rand()),
                listenContent
            );
            
            // 生成包装器
            std::string wrapper = CJMOD::CJMODFunctionGenerator::generateFunctionWrapper(functionInfo);
            
            // 替换原始代码
            result.replace(match.position(), match.length(), wrapper);
        }
        
        return result;
    }
};
```

---

## 📈 性能优化

### ⚡ 扫描性能优化

```cpp
/**
 * 扫描性能优化器
 */
class ScanningPerformanceOptimizer {
private:
    // 缓存系统
    std::unordered_map<std::string, std::vector<CodeFragment>> m_FragmentCache;
    std::unordered_map<std::string, SyntaxStructure> m_SyntaxCache;
    
    // 性能指标
    struct PerformanceMetrics {
        std::chrono::milliseconds ScanningTime;
        std::chrono::milliseconds AnalysisTime;
        std::chrono::milliseconds CJMODProcessingTime;
        size_t MemoryUsage;
        size_t CacheHitRate;
    };

public:
    /**
     * 优化扫描过程
     */
    std::vector<CodeFragment> OptimizedScan(const std::string& sourceCode) {
        auto startTime = std::chrono::high_resolution_clock::now();
        
        // 1. 检查缓存
        std::string cacheKey = GenerateCacheKey(sourceCode);
        if (m_FragmentCache.count(cacheKey)) {
            m_Metrics.CacheHitRate++;
            return m_FragmentCache[cacheKey];
        }
        
        // 2. 并行扫描
        auto fragments = PerformParallelScanning(sourceCode);
        
        // 3. 缓存结果
        m_FragmentCache[cacheKey] = fragments;
        
        // 4. 更新性能指标
        auto endTime = std::chrono::high_resolution_clock::now();
        m_Metrics.ScanningTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        
        return fragments;
    }

private:
    /**
     * 并行扫描
     */
    std::vector<CodeFragment> PerformParallelScanning(const std::string& sourceCode) {
        const size_t numThreads = std::thread::hardware_concurrency();
        const size_t chunkSize = sourceCode.length() / numThreads;
        
        std::vector<std::future<std::vector<CodeFragment>>> futures;
        std::vector<CodeFragment> allFragments;
        
        // 分块并行处理
        for (size_t i = 0; i < numThreads; ++i) {
            size_t startPos = i * chunkSize;
            size_t endPos = (i == numThreads - 1) ? sourceCode.length() : (i + 1) * chunkSize;
            
            std::string chunk = sourceCode.substr(startPos, endPos - startPos);
            
            futures.push_back(std::async(std::launch::async, [this, chunk, startPos]() {
                return this->ScanChunk(chunk, startPos);
            }));
        }
        
        // 收集结果
        for (auto& future : futures) {
            auto chunkFragments = future.get();
            allFragments.insert(allFragments.end(), chunkFragments.begin(), chunkFragments.end());
        }
        
        // 合并重叠片段
        return MergeOverlappingFragments(allFragments);
    }
};
```

### 🧠 智能缓存系统

```cpp
/**
 * 智能缓存管理器
 */
class IntelligentCacheManager {
private:
    // 缓存配置
    struct CacheConfig {
        size_t MaxCacheSize = 1000;          // 最大缓存条目
        std::chrono::minutes CacheTTL{30};    // 缓存生存时间
        double CacheHitThreshold = 0.8;      // 缓存命中阈值
        bool EnableIntelligentEviction = true; // 智能淘汰
    };
    
    // 缓存条目
    struct CacheEntry {
        std::vector<CodeFragment> Fragments;
        std::chrono::steady_clock::time_point CreationTime;
        size_t AccessCount;
        double SimilarityScore;
    };
    
    std::unordered_map<std::string, CacheEntry> m_Cache;
    CacheConfig m_Config;

public:
    /**
     * 智能缓存查找
     * @param sourceCode 源代码
     * @return 缓存的片段（如果存在）
     */
    std::optional<std::vector<CodeFragment>> SmartLookup(const std::string& sourceCode) {
        std::string exactKey = GenerateExactKey(sourceCode);
        
        // 1. 精确匹配
        if (m_Cache.count(exactKey)) {
            auto& entry = m_Cache[exactKey];
            entry.AccessCount++;
            return entry.Fragments;
        }
        
        // 2. 相似性匹配
        if (m_Config.EnableIntelligentEviction) {
            auto similarEntry = FindSimilarEntry(sourceCode);
            if (similarEntry.has_value() && 
                similarEntry->SimilarityScore >= m_Config.CacheHitThreshold) {
                
                // 基于相似代码调整片段
                return AdaptFragmentsForSimilarCode(similarEntry->Fragments, sourceCode);
            }
        }
        
        return std::nullopt;
    }
    
    /**
     * 智能缓存存储
     */
    void SmartStore(const std::string& sourceCode, const std::vector<CodeFragment>& fragments) {
        // 检查缓存大小
        if (m_Cache.size() >= m_Config.MaxCacheSize) {
            PerformIntelligentEviction();
        }
        
        std::string key = GenerateExactKey(sourceCode);
        CacheEntry entry;
        entry.Fragments = fragments;
        entry.CreationTime = std::chrono::steady_clock::now();
        entry.AccessCount = 1;
        entry.SimilarityScore = 1.0;
        
        m_Cache[key] = std::move(entry);
    }

private:
    /**
     * 智能淘汰策略
     */
    void PerformIntelligentEviction() {
        auto now = std::chrono::steady_clock::now();
        std::vector<std::string> keysToRemove;
        
        for (const auto& [key, entry] : m_Cache) {
            // 检查TTL
            if (now - entry.CreationTime > m_Config.CacheTTL) {
                keysToRemove.push_back(key);
                continue;
            }
            
            // 检查访问频率
            if (entry.AccessCount < 2) {
                keysToRemove.push_back(key);
            }
        }
        
        // 移除过期条目
        for (const auto& key : keysToRemove) {
            m_Cache.erase(key);
        }
        
        // 如果还需要空间，移除最少使用的条目
        if (m_Cache.size() >= m_Config.MaxCacheSize) {
            auto lruKey = FindLeastRecentlyUsed();
            m_Cache.erase(lruKey);
        }
    }
};
```

---

## 📊 监控和调试

### 🔍 扫描器监控

```cpp
/**
 * 扫描器性能监控
 */
class ScannerMonitor {
private:
    struct ScanningMetrics {
        size_t TotalFragments = 0;
        size_t CHTLFragments = 0;
        size_t CHTLJSFragments = 0;
        size_t CSSFragments = 0;
        size_t JSFragments = 0;
        size_t UnknownFragments = 0;
        
        std::chrono::milliseconds TotalScanTime{0};
        std::chrono::milliseconds AverageScanTime{0};
        size_t TotalBytesProcessed = 0;
        double ScanningSpeed = 0.0;  // bytes/ms
        
        size_t CacheHits = 0;
        size_t CacheMisses = 0;
        double CacheHitRate = 0.0;
    };

public:
    /**
     * 开始监控扫描过程
     */
    void StartMonitoring(const std::string& sourceCode) {
        m_CurrentMetrics = ScanningMetrics();
        m_StartTime = std::chrono::high_resolution_clock::now();
        m_CurrentMetrics.TotalBytesProcessed = sourceCode.length();
        
        std::cout << "🔍 开始扫描监控..." << std::endl;
        std::cout << "  源代码大小: " << sourceCode.length() << " 字节" << std::endl;
    }
    
    /**
     * 记录片段处理
     */
    void RecordFragmentProcessed(const CodeFragment& fragment) {
        m_CurrentMetrics.TotalFragments++;
        
        switch (fragment.Type) {
            case FragmentType::CHTL_FRAGMENT:
                m_CurrentMetrics.CHTLFragments++;
                break;
            case FragmentType::CHTL_JS_FRAGMENT:
                m_CurrentMetrics.CHTLJSFragments++;
                break;
            case FragmentType::CSS_FRAGMENT:
                m_CurrentMetrics.CSSFragments++;
                break;
            case FragmentType::JAVASCRIPT_FRAGMENT:
                m_CurrentMetrics.JSFragments++;
                break;
            default:
                m_CurrentMetrics.UnknownFragments++;
                break;
        }
    }
    
    /**
     * 完成监控并生成报告
     */
    void FinishMonitoring() {
        auto endTime = std::chrono::high_resolution_clock::now();
        m_CurrentMetrics.TotalScanTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - m_StartTime);
        
        if (m_CurrentMetrics.TotalFragments > 0) {
            m_CurrentMetrics.AverageScanTime = m_CurrentMetrics.TotalScanTime / m_CurrentMetrics.TotalFragments;
        }
        
        m_CurrentMetrics.ScanningSpeed = m_CurrentMetrics.TotalBytesProcessed / 
                                        static_cast<double>(m_CurrentMetrics.TotalScanTime.count());
        
        m_CurrentMetrics.CacheHitRate = m_CurrentMetrics.CacheHits / 
                                       static_cast<double>(m_CurrentMetrics.CacheHits + m_CurrentMetrics.CacheMisses);
        
        GeneratePerformanceReport();
    }

private:
    /**
     * 生成性能报告
     */
    void GeneratePerformanceReport() {
        std::cout << std::endl;
        std::cout << "📊 扫描器性能报告" << std::endl;
        std::cout << "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" << std::endl;
        std::cout << "总片段数: " << m_CurrentMetrics.TotalFragments << std::endl;
        std::cout << "  ├─ CHTL片段: " << m_CurrentMetrics.CHTLFragments << std::endl;
        std::cout << "  ├─ CHTL JS片段: " << m_CurrentMetrics.CHTLJSFragments << std::endl;
        std::cout << "  ├─ CSS片段: " << m_CurrentMetrics.CSSFragments << std::endl;
        std::cout << "  ├─ JavaScript片段: " << m_CurrentMetrics.JSFragments << std::endl;
        std::cout << "  └─ 未知片段: " << m_CurrentMetrics.UnknownFragments << std::endl;
        std::cout << std::endl;
        std::cout << "性能指标:" << std::endl;
        std::cout << "  总扫描时间: " << m_CurrentMetrics.TotalScanTime.count() << "ms" << std::endl;
        std::cout << "  平均片段时间: " << m_CurrentMetrics.AverageScanTime.count() << "ms" << std::endl;
        std::cout << "  扫描速度: " << m_CurrentMetrics.ScanningSpeed << " 字节/ms" << std::endl;
        std::cout << "  缓存命中率: " << (m_CurrentMetrics.CacheHitRate * 100) << "%" << std::endl;
        std::cout << "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" << std::endl;
    }
};
```

---

## 🎯 扩展性设计

### 🔌 新语言支持

```cpp
/**
 * 语言扩展接口
 */
class LanguageExtension {
public:
    virtual ~LanguageExtension() = default;
    
    /**
     * 语言识别
     * @param code 代码片段
     * @return 是否匹配此语言
     */
    virtual bool CanHandle(const std::string& code) = 0;
    
    /**
     * 片段处理
     * @param fragment 代码片段
     * @return 处理后的片段
     */
    virtual CodeFragment ProcessFragment(const CodeFragment& fragment) = 0;
    
    /**
     * 获取语言信息
     */
    virtual LanguageInfo GetLanguageInfo() = 0;
};

/**
 * TypeScript扩展示例
 */
class TypeScriptExtension : public LanguageExtension {
public:
    bool CanHandle(const std::string& code) override {
        // TypeScript特征检测
        static const std::vector<std::regex> tsPatterns = {
            std::regex(R"(\binterface\s+\w+)"),
            std::regex(R"(\btype\s+\w+\s*=)"),
            std::regex(R"(:\s*\w+(\[\])?(\s*\|)?)"),  // 类型注解
            std::regex(R"(\bpublic\s+\w+)"),
            std::regex(R"(\bprivate\s+\w+)")
        };
        
        for (const auto& pattern : tsPatterns) {
            if (std::regex_search(code, pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    CodeFragment ProcessFragment(const CodeFragment& fragment) override {
        CodeFragment processed = fragment;
        processed.Type = FragmentType::TYPESCRIPT_FRAGMENT;
        
        // TypeScript特殊处理逻辑
        processed.Content = ProcessTypeScriptCode(fragment.Content);
        
        return processed;
    }
    
    LanguageInfo GetLanguageInfo() override {
        return {
            .Name = "TypeScript",
            .Version = "4.9",
            .FileExtensions = {".ts", ".tsx"},
            .MimeType = "application/typescript"
        };
    }
};

/**
 * 扩展管理器
 */
class LanguageExtensionManager {
private:
    std::vector<std::unique_ptr<LanguageExtension>> m_Extensions;

public:
    /**
     * 注册语言扩展
     */
    void RegisterExtension(std::unique_ptr<LanguageExtension> extension) {
        m_Extensions.push_back(std::move(extension));
    }
    
    /**
     * 查找合适的扩展
     */
    LanguageExtension* FindExtensionForCode(const std::string& code) {
        for (auto& extension : m_Extensions) {
            if (extension->CanHandle(code)) {
                return extension.get();
            }
        }
        return nullptr;
    }
};
```

---

## 🛠️ 调试工具

### 🔍 扫描器调试器

```cpp
/**
 * 扫描器调试工具
 */
class ScannerDebugger {
public:
    /**
     * 启用详细调试
     */
    void EnableVerboseDebugging(bool enable) {
        m_VerboseMode = enable;
        if (enable) {
            std::cout << "🔍 扫描器详细调试模式已启用" << std::endl;
        }
    }
    
    /**
     * 记录扫描步骤
     */
    void LogScanStep(const std::string& step, const std::string& details) {
        if (m_VerboseMode) {
            std::cout << "  🔸 " << step << ": " << details << std::endl;
        }
    }
    
    /**
     * 生成可视化报告
     */
    void GenerateVisualReport(const std::vector<CodeFragment>& fragments) {
        std::cout << std::endl;
        std::cout << "📊 扫描器可视化报告" << std::endl;
        std::cout << "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" << std::endl;
        
        // 片段类型统计
        std::unordered_map<FragmentType, int> typeCount;
        for (const auto& fragment : fragments) {
            typeCount[fragment.Type]++;
        }
        
        std::cout << "片段类型分布:" << std::endl;
        for (const auto& [type, count] : typeCount) {
            std::cout << "  " << GetFragmentTypeName(type) << ": " << count << " 个" << std::endl;
        }
        
        std::cout << std::endl;
        
        // 片段详细信息
        std::cout << "片段详细信息:" << std::endl;
        for (size_t i = 0; i < fragments.size() && i < 10; ++i) {  // 只显示前10个
            const auto& fragment = fragments[i];
            std::cout << "  [" << i << "] " << GetFragmentTypeName(fragment.Type) 
                      << " (" << fragment.StartPosition << "-" << fragment.EndPosition << ")" << std::endl;
            
            // 显示内容预览
            std::string preview = fragment.Content.substr(0, 50);
            if (fragment.Content.length() > 50) {
                preview += "...";
            }
            std::cout << "      \"" << preview << "\"" << std::endl;
        }
        
        if (fragments.size() > 10) {
            std::cout << "  ... 还有 " << (fragments.size() - 10) << " 个片段" << std::endl;
        }
        
        std::cout << "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" << std::endl;
    }
};
```

---

## 🎊 总结

统一扫描器架构是CHTL编译器的核心创新，提供了：

- 🔥 **精准代码切割** - 可变长度切片和最小语法单元识别
- 🔥 **智能类型识别** - 多语言混合代码的准确分类
- 🔥 **高效处理** - 并行扫描和智能缓存
- 🔥 **CJMOD集成** - 与CJMOD系统的深度集成
- 🔥 **扩展性设计** - 支持新语言类型的扩展
- 🔥 **性能监控** - 完整的性能分析和调试工具

统一扫描器使得CHTL编译器能够处理复杂的多语言混合代码，为双语言分离架构和四编译器协调系统提供了坚实的基础。

**🌟 统一扫描器 - CHTL编译器架构的核心创新！**