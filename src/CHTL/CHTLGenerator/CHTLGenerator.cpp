#include "CHTLGenerator.h"
#include <sstream>
#include <regex>
#include <algorithm>
#include <iostream>

namespace CHTL {

CHTLGenerator::CHTLGenerator() 
    : CHTLDefaultVisitor(), m_HasError(false), m_GenerateIndentedHTML(true), m_MinifyCSS(false), 
      m_AddSourceComments(true), m_IndentLevel(0) {
    
    // æš‚æ—¶æ³¨é‡Šé«˜çº§åŠŸèƒ½å¼•æ“åˆå§‹åŒ–
    // m_SelectorEngine = std::make_unique<SelectorAutomationEngine>();
    // m_TemplateEngine = std::make_unique<TemplateEngine>();
    // m_CustomEngine = std::make_unique<CustomEngine>(m_TemplateEngine.get());
    
    std::cout << "ğŸš€ CHTLç”Ÿæˆå™¨åˆå§‹åŒ–å®Œæˆï¼Œæ ¸å¿ƒåŠŸèƒ½å·²å°±ç»ª" << std::endl;
}

GenerationResult CHTLGenerator::Generate(std::unique_ptr<CHTLBaseNode> rootNode) {
    GenerationResult result;
    
    if (!rootNode) {
        result.IsSuccess = false;
        result.ErrorMessage = "Root node is null";
        return result;
    }
    
    m_RootNode = std::move(rootNode);
    Reset();
    
    try {
        // é¢„å¤„ç†é˜¶æ®µï¼šæ”¶é›†æ¨¡æ¿å’Œè‡ªå®šä¹‰å®šä¹‰
        CollectTemplatesAndCustoms(m_RootNode.get());
        
        // å¤„ç†ç»§æ‰¿å’Œç‰¹ä¾‹åŒ–
        ProcessTemplateInheritance();
        ProcessCustomInheritanceAndSpecialization();
        
        // è§£æå˜é‡å¼•ç”¨
        ResolveVariableReferences();
        
        // ç”ŸæˆHTMLæ–‡æ¡£
        GenerateHTMLDocument(m_RootNode.get());
        
        // ç”ŸæˆCSSæ ·å¼è¡¨  
        GenerateCSSStylesheet(m_RootNode.get());
        
        // ç”ŸæˆJavaScriptä»£ç ï¼ˆæ¥è‡ªå±€éƒ¨scriptï¼‰
        GenerateJavaScriptCode(m_RootNode.get());
        
        // éªŒè¯ç”Ÿæˆçš„ä»£ç 
        if (!ValidateGeneratedCode()) {
            result.IsSuccess = false;
            result.ErrorMessage = "Generated code validation failed";
            return result;
        }
        
        // ä¼˜åŒ–ç”Ÿæˆçš„ä»£ç 
        if (m_MinifyCSS) {
            OptimizeGeneratedCSS();
        }
        OptimizeGeneratedHTML();
        
        // ç»„è£…æœ€ç»ˆç»“æœ
        result.HTMLContent = m_GeneratedHTML;
        result.CSSContent = m_GeneratedCSS;
        result.JavaScriptContent = m_GeneratedJS;
        
        // ç”Ÿæˆå®Œæ•´HTMLæ–‡æ¡£
        std::ostringstream fullHTML;
        fullHTML << "<!DOCTYPE html>\n";
        fullHTML << "<html>\n";
        fullHTML << "<head>\n";
        fullHTML << "    <meta charset=\"UTF-8\">\n";
        fullHTML << "    <title>CHTL Generated Document</title>\n";
        
        if (!m_GeneratedCSS.empty()) {
            fullHTML << "    <style>\n";
            if (m_AddSourceComments) {
                fullHTML << "        /* Generated by CHTL Compiler - CSS from local style blocks */\n";
            }
            fullHTML << m_GeneratedCSS;
            fullHTML << "    </style>\n";
        }
        
        fullHTML << "</head>\n";
        fullHTML << "<body>\n";
        fullHTML << m_GeneratedHTML;
        fullHTML << "</body>\n";
        
        if (!m_GeneratedJS.empty()) {
            fullHTML << "<script>\n";
            if (m_AddSourceComments) {
                fullHTML << "    // Generated by CHTL Compiler - JavaScript from local script blocks\n";
            }
            fullHTML << m_GeneratedJS;
            fullHTML << "</script>\n";
        }
        
        fullHTML << "</html>";
        
        result.FullHTMLDocument = fullHTML.str();
        result.IsSuccess = true;
        result.Warnings = m_Warnings;
        
    }
    catch (const std::exception& e) {
        result.IsSuccess = false;
        result.ErrorMessage = "Generation exception: " + std::string(e.what());
    }
    
    return result;
}

void CHTLGenerator::SetAST(std::shared_ptr<CHTLBaseNode> rootNode) {
    m_ASTRoot = rootNode;
}

std::string CHTLGenerator::GenerateHTML() {
    if (!m_ASTRoot) {
        return "<p>No AST provided</p>";
    }
    
    try {
        // é‡ç½®ç”ŸæˆçŠ¶æ€
        m_GeneratedHTML.clear();
        m_GeneratedCSS.clear();
        m_GeneratedJS.clear();
        m_HasError = false;
        m_ErrorMessage.clear();
        m_Warnings.clear();
        
        // ç”ŸæˆHTML
        GenerateHTMLDocument(m_ASTRoot.get());
        
        return m_GeneratedHTML;
    }
    catch (const std::exception& e) {
        SetError("HTML generation error: " + std::string(e.what()));
        return "<p>HTML generation failed: " + std::string(e.what()) + "</p>";
    }
}

void CHTLGenerator::VisitElementNode(ElementNode* node) {
    if (!node) {
        return;
    }
    
    std::ostringstream html;
    
    if (m_AddSourceComments) {
        html << AddSourceComment("Element: " + node->GetTagName(), "HTML");
    }
    
    // ç”Ÿæˆå¼€å§‹æ ‡ç­¾
    html << GenerateIndent() << node->GenerateOpenTag();
    
    if (!node->IsSelfClosing()) {
        html << "\n";
        m_IndentLevel++;
        
        // ç”Ÿæˆå­èŠ‚ç‚¹å†…å®¹
        for (const auto& child : node->GetChildren()) {
            child->Accept(this);
        }
        
        m_IndentLevel--;
        html << GenerateIndent() << node->GenerateCloseTag();
    }
    
    html << "\n";
    
    m_GeneratedHTML += html.str();
    
    // å¤„ç†å±€éƒ¨æ ·å¼å—
    for (const auto& styleNode : node->GetStyleNodes()) {
        if (styleNode->GetType() == CHTLNodeType::STYLE_NODE) {
            StyleNode* style = static_cast<StyleNode*>(styleNode.get());
            GenerateLocalStyleGlobalCSS(style, node);
        }
    }
    
    // å¤„ç†å±€éƒ¨è„šæœ¬å—
    for (const auto& scriptNode : node->GetScriptNodes()) {
        if (scriptNode->GetType() == CHTLNodeType::SCRIPT_NODE) {
            ScriptNode* script = static_cast<ScriptNode*>(scriptNode.get());
            GenerateLocalScriptJavaScript(script, node);
        }
    }
}

void CHTLGenerator::VisitTextNode(TextNode* node) {
    if (!node) {
        return;
    }
    
    std::string textContent = node->GetHTMLSafeText();
    
    // å¤„ç†UTF-8å­—ç¬¦
    textContent = ProcessUTF8Text(textContent);
    
    if (m_GenerateIndentedHTML) {
        m_GeneratedHTML += GenerateIndent() + textContent + "\n";
    }
    else {
        m_GeneratedHTML += textContent;
    }
}

void CHTLGenerator::VisitStyleNode(StyleNode* node) {
    if (!node) {
        return;
    }
    
    // å±€éƒ¨æ ·å¼å—çš„CSSç”Ÿæˆåœ¨VisitElementNodeä¸­å¤„ç†
    // è¿™é‡Œä¸»è¦å¤„ç†å…¨å±€æ ·å¼å—ï¼ˆå¦‚æœæœ‰ï¼‰
    
    if (m_AddSourceComments) {
        m_GeneratedCSS += AddSourceComment("Local style block", "CSS");
    }
    
    // ç”Ÿæˆå…¨å±€CSS
    std::string globalCSS = node->GenerateGlobalCSS();
    if (!globalCSS.empty()) {
        m_GeneratedCSS += globalCSS;
    }
}

void CHTLGenerator::VisitScriptNode(ScriptNode* node) {
    if (!node) {
        return;
    }
    
    // å±€éƒ¨è„šæœ¬å—çš„JavaScriptç”Ÿæˆåœ¨VisitElementNodeä¸­å¤„ç†
    // è¿™é‡Œä¸»è¦å¤„ç†å…¨å±€è„šæœ¬å—ï¼ˆå¦‚æœæœ‰ï¼‰
    
    if (m_AddSourceComments) {
        m_GeneratedJS += AddSourceComment("Local script block", "JS");
    }
    
    // ç”ŸæˆJavaScriptä»£ç 
    std::string jsCode = node->GenerateJavaScript();
    if (!jsCode.empty()) {
        m_GeneratedJS += jsCode;
    }
}

void CHTLGenerator::CollectTemplatesAndCustoms(CHTLBaseNode* node) {
    if (!node) {
        return;
    }
    
    // æ”¶é›†æ¨¡æ¿å®šä¹‰
    if (node->GetType() == CHTLNodeType::TEMPLATE_STYLE_NODE ||
        node->GetType() == CHTLNodeType::TEMPLATE_ELEMENT_NODE ||
        node->GetType() == CHTLNodeType::TEMPLATE_VAR_NODE) {
        
        TemplateNode* templateNode = static_cast<TemplateNode*>(node);
        
        switch (templateNode->GetTemplateType()) {
            case TemplateType::STYLE_TEMPLATE:
                m_StyleTemplates[templateNode->GetTemplateName()] = templateNode;
                break;
            case TemplateType::ELEMENT_TEMPLATE:
                m_ElementTemplates[templateNode->GetTemplateName()] = templateNode;
                break;
            case TemplateType::VAR_TEMPLATE:
                m_VarTemplates[templateNode->GetTemplateName()] = templateNode;
                break;
        }
    }
    
    // æ”¶é›†è‡ªå®šä¹‰å®šä¹‰
    if (node->GetType() == CHTLNodeType::CUSTOM_STYLE_NODE ||
        node->GetType() == CHTLNodeType::CUSTOM_ELEMENT_NODE ||
        node->GetType() == CHTLNodeType::CUSTOM_VAR_NODE) {
        
        CustomNode* customNode = static_cast<CustomNode*>(node);
        
        switch (customNode->GetCustomType()) {
            case CustomType::STYLE_CUSTOM:
                m_StyleCustoms[customNode->GetCustomName()] = customNode;
                break;
            case CustomType::ELEMENT_CUSTOM:
                m_ElementCustoms[customNode->GetCustomName()] = customNode;
                break;
            case CustomType::VAR_CUSTOM:
                m_VarCustoms[customNode->GetCustomName()] = customNode;
                break;
        }
    }
    
    // é€’å½’å¤„ç†å­èŠ‚ç‚¹
    for (const auto& child : node->GetChildren()) {
        CollectTemplatesAndCustoms(child.get());
    }
}

void CHTLGenerator::GenerateLocalStyleGlobalCSS(StyleNode* styleNode, ElementNode* contextElement) {
    if (!styleNode || !contextElement) {
        return;
    }
    
    // ç”Ÿæˆå±€éƒ¨æ ·å¼å—çš„å…¨å±€CSS
    const auto& styleRules = styleNode->GetStyleRules();
    
    for (const auto& rule : styleRules) {
        if (rule.IsGlobalStyle && !rule.Selector.empty()) {
            std::string resolvedSelector = rule.Selector;
            
            // å¤„ç†ä¸Šä¸‹æ–‡å¼•ç”¨
            if (rule.Selector.find('&') != std::string::npos) {
                resolvedSelector = ResolveContextReference(rule.Selector, 
                                                          contextElement->GetFirstAutoClass(),
                                                          contextElement->GetFirstAutoId());
            }
            
            GenerateSelectorCSSRule(resolvedSelector, rule.Properties);
        }
    }
}

void CHTLGenerator::GenerateLocalScriptJavaScript(ScriptNode* scriptNode, ElementNode* contextElement) {
    if (!scriptNode || !contextElement) {
        return;
    }
    
    // ç”Ÿæˆå±€éƒ¨è„šæœ¬å—çš„JavaScript
    std::string jsCode = scriptNode->GenerateJavaScript(contextElement->GetFirstAutoClass(),
                                                        contextElement->GetFirstAutoId());
    
    if (!jsCode.empty()) {
        if (m_AddSourceComments) {
            m_GeneratedJS += AddSourceComment("Local script from " + contextElement->GetTagName(), "JS");
        }
        
        m_GeneratedJS += jsCode + "\n";
    }
}

void CHTLGenerator::GenerateSelectorCSSRule(const std::string& selector, 
                                           const std::unordered_map<std::string, std::string>& properties) {
    if (properties.empty()) {
        return;
    }
    
    std::ostringstream css;
    
    css << selector << " {\n";
    
    for (const auto& prop : properties) {
        css << "  " << prop.first << ": " << prop.second << ";\n";
    }
    
    css << "}\n\n";
    
    m_GeneratedCSS += css.str();
}

std::string CHTLGenerator::ResolveContextReference(const std::string& selector, 
                                                  const std::string& contextClass, 
                                                  const std::string& contextId) {
    std::string result = selector;
    
    // å±€éƒ¨styleä¼˜å…ˆé€‰æ‹©class
    std::string contextSelector;
    if (!contextClass.empty()) {
        contextSelector = "." + contextClass;
    }
    else if (!contextId.empty()) {
        contextSelector = "#" + contextId;
    }
    
    if (!contextSelector.empty()) {
        // æ›¿æ¢&å¼•ç”¨
        std::regex contextPattern(R"(&)");
        result = std::regex_replace(result, contextPattern, contextSelector);
    }
    
    return result;
}

std::string CHTLGenerator::GenerateIndent(int level) {
    if (level == -1) {
        level = m_IndentLevel;
    }
    
    return std::string(level * 2, ' ');
}

std::string CHTLGenerator::AddSourceComment(const std::string& comment, const std::string& type) {
    if (!m_AddSourceComments) {
        return "";
    }
    
    if (type == "HTML") {
        return "<!-- " + comment + " -->\n";
    }
    else if (type == "CSS") {
        return "/* " + comment + " */\n";
    }
    else if (type == "JS") {
        return "// " + comment + "\n";
    }
    
    return "";
}

std::string CHTLGenerator::EscapeHTML(const std::string& text) {
    std::string result = text;
    
    // HTMLå­—ç¬¦è½¬ä¹‰
    std::regex htmlEscapePatterns[] = {
        std::regex("&"),
        std::regex("<"),
        std::regex(">"),
        std::regex("\""),
        std::regex("'")
    };
    
    std::string htmlEscapeReplacements[] = {
        "&amp;", "&lt;", "&gt;", "&quot;", "&#39;"
    };
    
    for (size_t i = 0; i < 5; ++i) {
        result = std::regex_replace(result, htmlEscapePatterns[i], htmlEscapeReplacements[i]);
    }
    
    return result;
}

std::string CHTLGenerator::ProcessUTF8Text(const std::string& text) {
    // ç¡®ä¿UTF-8å­—ç¬¦æ­£ç¡®å¤„ç†
    return text; // æš‚æ—¶ç›´æ¥è¿”å›ï¼Œå®é™…å¯èƒ½éœ€è¦æ›´å¤æ‚çš„å¤„ç†
}

void CHTLGenerator::SetGenerationOptions(bool indentedHTML, bool minifyCSS, bool sourceComments) {
    m_GenerateIndentedHTML = indentedHTML;
    m_MinifyCSS = minifyCSS;
    m_AddSourceComments = sourceComments;
}

void CHTLGenerator::Reset() {
    // é‡ç½®ç”Ÿæˆå™¨çŠ¶æ€
    
    m_GeneratedHTML.clear();
    m_GeneratedCSS.clear();
    m_GeneratedJS.clear();
    
    m_StyleTemplates.clear();
    m_ElementTemplates.clear();
    m_VarTemplates.clear();
    m_StyleCustoms.clear();
    m_ElementCustoms.clear();
    m_VarCustoms.clear();
    
    m_GlobalStyleRules.clear();
    m_GlobalSelectors.clear();
    m_AutoClassMap.clear();
    m_AutoIdMap.clear();
    
    m_HasError = false;
    m_ErrorMessage.clear();
    m_Warnings.clear();
    m_IndentLevel = 0;
}

// å ä½å®ç°ï¼ˆéœ€è¦åç»­å®Œå–„ï¼‰
void CHTLGenerator::ProcessTemplateInheritance() {
    // å¤„ç†æ¨¡æ¿ç»§æ‰¿é€»è¾‘
    for (auto& templatePair : m_StyleTemplates) {
        TemplateNode* templateNode = templatePair.second;
        
        // åº”ç”¨ç»§æ‰¿è§„åˆ™
        for (const auto& inheritedTemplate : templateNode->GetInheritedTemplates()) {
            auto parentIt = m_StyleTemplates.find(inheritedTemplate);
            if (parentIt != m_StyleTemplates.end()) {
                templateNode->ApplyTemplateInheritance(parentIt->second);
            }
        }
    }
}

void CHTLGenerator::ProcessCustomInheritanceAndSpecialization() {
    // å¤„ç†è‡ªå®šä¹‰ç»§æ‰¿å’Œç‰¹ä¾‹åŒ–é€»è¾‘
}

void CHTLGenerator::ResolveVariableReferences() {
    // è§£æå˜é‡å¼•ç”¨é€»è¾‘
}

void CHTLGenerator::GenerateHTMLDocument(CHTLBaseNode* node) {
    if (node) {
        node->Accept(this);
    }
}

void CHTLGenerator::GenerateCSSStylesheet(CHTLBaseNode* node) {
    // CSSæ ·å¼è¡¨ç”Ÿæˆé€»è¾‘å·²åœ¨è®¿é—®è€…æ–¹æ³•ä¸­å®ç°
}

void CHTLGenerator::GenerateJavaScriptCode(CHTLBaseNode* node) {
    // JavaScriptä»£ç ç”Ÿæˆé€»è¾‘å·²åœ¨è®¿é—®è€…æ–¹æ³•ä¸­å®ç°
}

bool CHTLGenerator::ValidateGeneratedCode() {
    // éªŒè¯ç”Ÿæˆçš„ä»£ç æœ‰æ•ˆæ€§
    return !m_GeneratedHTML.empty() || !m_GeneratedCSS.empty() || !m_GeneratedJS.empty();
}

void CHTLGenerator::OptimizeGeneratedCSS() {
    if (m_MinifyCSS) {
        // CSSå‹ç¼©é€»è¾‘
        std::regex whitespacePattern(R"(\s+)");
        m_GeneratedCSS = std::regex_replace(m_GeneratedCSS, whitespacePattern, " ");
        
        std::regex newlinePattern(R"(\n\s*)");
        m_GeneratedCSS = std::regex_replace(m_GeneratedCSS, newlinePattern, "");
    }
}

void CHTLGenerator::OptimizeGeneratedHTML() {
    // HTMLä¼˜åŒ–é€»è¾‘
    if (!m_GenerateIndentedHTML) {
        // ç§»é™¤å¤šä½™çš„ç©ºç™½
        std::regex excessWhitespacePattern(R"(\n\s*\n)");
        m_GeneratedHTML = std::regex_replace(m_GeneratedHTML, excessWhitespacePattern, "\n");
    }
}

void CHTLGenerator::SetGenerationError(const std::string& message) {
    m_HasError = true;
    m_ErrorMessage = message;
}

void CHTLGenerator::AddGenerationWarning(const std::string& message) {
    m_Warnings.push_back(message);
}

std::string CHTLGenerator::ResolveVariableReference(const std::string& variableRef) {
    // è§£æå˜é‡å¼•ç”¨ï¼šThemeColor(tableColor)
    std::regex varPattern(R"(([a-zA-Z][a-zA-Z0-9_]*)\(([a-zA-Z][a-zA-Z0-9_]*)\))");
    std::smatch match;
    
    if (std::regex_match(variableRef, match, varPattern)) {
        std::string varGroup = match[1].str();
        std::string varName = match[2].str();
        
        // æŸ¥æ‰¾å˜é‡ç»„æ¨¡æ¿
        auto templateIt = m_VarTemplates.find(varGroup);
        if (templateIt != m_VarTemplates.end()) {
            return templateIt->second->GetTemplateProperty(varName);
        }
        
        // æŸ¥æ‰¾å˜é‡è‡ªå®šä¹‰
        auto customIt = m_VarCustoms.find(varGroup);
        if (customIt != m_VarCustoms.end()) {
            return customIt->second->GetCustomProperty(varName);
        }
    }
    
    return variableRef; // æ— æ³•è§£æï¼Œè¿”å›åŸå€¼
}

std::unordered_map<std::string, std::string> CHTLGenerator::ExpandStyleTemplate(const std::string& templateName) {
    auto it = m_StyleTemplates.find(templateName);
    if (it != m_StyleTemplates.end()) {
        return it->second->GetTemplateProperties();
    }
    
    return {};
}

void CHTLGenerator::SetError(const std::string& message) {
    m_HasError = true;
    m_ErrorMessage = message;
    std::cerr << "CHTL Generator Error: " << message << std::endl;
}



} // namespace CHTL