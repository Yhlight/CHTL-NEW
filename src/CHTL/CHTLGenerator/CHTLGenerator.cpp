#include "CHTLGenerator.h"
#include <sstream>
#include <regex>
#include <algorithm>
#include <iostream>

namespace CHTL {

CHTLGenerator::CHTLGenerator() 
    : CHTLDefaultVisitor(), m_HasError(false), m_GenerateIndentedHTML(true), m_MinifyCSS(false), 
      m_AddSourceComments(true), m_IndentLevel(0) {
    
    // 暂时注释高级功能引擎初始化
    // m_SelectorEngine = std::make_unique<SelectorAutomationEngine>();
    // m_TemplateEngine = std::make_unique<TemplateEngine>();
    // m_CustomEngine = std::make_unique<CustomEngine>(m_TemplateEngine.get());
    
    std::cout << "🚀 CHTL生成器初始化完成，核心功能已就绪" << std::endl;
}

GenerationResult CHTLGenerator::Generate(std::unique_ptr<CHTLBaseNode> rootNode) {
    GenerationResult result;
    
    if (!rootNode) {
        result.IsSuccess = false;
        result.ErrorMessage = "Root node is null";
        return result;
    }
    
    m_RootNode = std::move(rootNode);
    Reset();
    
    try {
        // 预处理阶段：收集模板和自定义定义
        CollectTemplatesAndCustoms(m_RootNode.get());
        
        // 处理继承和特例化
        ProcessTemplateInheritance();
        ProcessCustomInheritanceAndSpecialization();
        
        // 解析变量引用
        ResolveVariableReferences();
        
        // 生成HTML文档
        GenerateHTMLDocument(m_RootNode.get());
        
        // 生成CSS样式表  
        GenerateCSSStylesheet(m_RootNode.get());
        
        // 生成JavaScript代码（来自局部script）
        GenerateJavaScriptCode(m_RootNode.get());
        
        // 验证生成的代码
        if (!ValidateGeneratedCode()) {
            result.IsSuccess = false;
            result.ErrorMessage = "Generated code validation failed";
            return result;
        }
        
        // 优化生成的代码
        if (m_MinifyCSS) {
            OptimizeGeneratedCSS();
        }
        OptimizeGeneratedHTML();
        
        // 组装最终结果
        result.HTMLContent = m_GeneratedHTML;
        result.CSSContent = m_GeneratedCSS;
        result.JavaScriptContent = m_GeneratedJS;
        
        // 生成完整HTML文档
        std::ostringstream fullHTML;
        fullHTML << "<!DOCTYPE html>\n";
        fullHTML << "<html>\n";
        fullHTML << "<head>\n";
        fullHTML << "    <meta charset=\"UTF-8\">\n";
        fullHTML << "    <title>CHTL Generated Document</title>\n";
        
        if (!m_GeneratedCSS.empty()) {
            fullHTML << "    <style>\n";
            if (m_AddSourceComments) {
                fullHTML << "        /* Generated by CHTL Compiler - CSS from local style blocks */\n";
            }
            fullHTML << m_GeneratedCSS;
            fullHTML << "    </style>\n";
        }
        
        fullHTML << "</head>\n";
        fullHTML << "<body>\n";
        fullHTML << m_GeneratedHTML;
        fullHTML << "</body>\n";
        
        if (!m_GeneratedJS.empty()) {
            fullHTML << "<script>\n";
            if (m_AddSourceComments) {
                fullHTML << "    // Generated by CHTL Compiler - JavaScript from local script blocks\n";
            }
            fullHTML << m_GeneratedJS;
            fullHTML << "</script>\n";
        }
        
        fullHTML << "</html>";
        
        result.FullHTMLDocument = fullHTML.str();
        result.IsSuccess = true;
        result.Warnings = m_Warnings;
        
    }
    catch (const std::exception& e) {
        result.IsSuccess = false;
        result.ErrorMessage = "Generation exception: " + std::string(e.what());
    }
    
    return result;
}

void CHTLGenerator::SetAST(std::shared_ptr<CHTLBaseNode> rootNode) {
    m_ASTRoot = rootNode;
}

std::string CHTLGenerator::GenerateHTML() {
    if (!m_ASTRoot) {
        return "<p>No AST provided</p>";
    }
    
    try {
        // 重置生成状态
        m_GeneratedHTML.clear();
        m_GeneratedCSS.clear();
        m_GeneratedJS.clear();
        m_HasError = false;
        m_ErrorMessage.clear();
        m_Warnings.clear();
        
        // 生成HTML
        GenerateHTMLDocument(m_ASTRoot.get());
        
        return m_GeneratedHTML;
    }
    catch (const std::exception& e) {
        SetError("HTML generation error: " + std::string(e.what()));
        return "<p>HTML generation failed: " + std::string(e.what()) + "</p>";
    }
}

void CHTLGenerator::VisitElementNode(ElementNode* node) {
    if (!node) {
        return;
    }
    
    std::ostringstream html;
    
    if (m_AddSourceComments) {
        html << AddSourceComment("Element: " + node->GetTagName(), "HTML");
    }
    
    // 生成开始标签
    html << GenerateIndent() << node->GenerateOpenTag();
    
    if (!node->IsSelfClosing()) {
        html << "\n";
        m_IndentLevel++;
        
        // 生成子节点内容
        for (const auto& child : node->GetChildren()) {
            child->Accept(this);
        }
        
        m_IndentLevel--;
        html << GenerateIndent() << node->GenerateCloseTag();
    }
    
    html << "\n";
    
    m_GeneratedHTML += html.str();
    
    // 处理局部样式块
    for (const auto& styleNode : node->GetStyleNodes()) {
        if (styleNode->GetType() == CHTLNodeType::STYLE_NODE) {
            StyleNode* style = static_cast<StyleNode*>(styleNode.get());
            GenerateLocalStyleGlobalCSS(style, node);
        }
    }
    
    // 处理局部脚本块
    for (const auto& scriptNode : node->GetScriptNodes()) {
        if (scriptNode->GetType() == CHTLNodeType::SCRIPT_NODE) {
            ScriptNode* script = static_cast<ScriptNode*>(scriptNode.get());
            GenerateLocalScriptJavaScript(script, node);
        }
    }
}

void CHTLGenerator::VisitTextNode(TextNode* node) {
    if (!node) {
        return;
    }
    
    std::string textContent = node->GetHTMLSafeText();
    
    // 处理UTF-8字符
    textContent = ProcessUTF8Text(textContent);
    
    if (m_GenerateIndentedHTML) {
        m_GeneratedHTML += GenerateIndent() + textContent + "\n";
    }
    else {
        m_GeneratedHTML += textContent;
    }
}

void CHTLGenerator::VisitStyleNode(StyleNode* node) {
    if (!node) {
        return;
    }
    
    // 局部样式块的CSS生成在VisitElementNode中处理
    // 这里主要处理全局样式块（如果有）
    
    if (m_AddSourceComments) {
        m_GeneratedCSS += AddSourceComment("Local style block", "CSS");
    }
    
    // 生成全局CSS
    std::string globalCSS = node->GenerateGlobalCSS();
    if (!globalCSS.empty()) {
        m_GeneratedCSS += globalCSS;
    }
}

void CHTLGenerator::VisitScriptNode(ScriptNode* node) {
    if (!node) {
        return;
    }
    
    // 局部脚本块的JavaScript生成在VisitElementNode中处理
    // 这里主要处理全局脚本块（如果有）
    
    if (m_AddSourceComments) {
        m_GeneratedJS += AddSourceComment("Local script block", "JS");
    }
    
    // 生成JavaScript代码
    std::string jsCode = node->GenerateJavaScript();
    if (!jsCode.empty()) {
        m_GeneratedJS += jsCode;
    }
}

void CHTLGenerator::CollectTemplatesAndCustoms(CHTLBaseNode* node) {
    if (!node) {
        return;
    }
    
    // 收集模板定义
    if (node->GetType() == CHTLNodeType::TEMPLATE_STYLE_NODE ||
        node->GetType() == CHTLNodeType::TEMPLATE_ELEMENT_NODE ||
        node->GetType() == CHTLNodeType::TEMPLATE_VAR_NODE) {
        
        TemplateNode* templateNode = static_cast<TemplateNode*>(node);
        
        switch (templateNode->GetTemplateType()) {
            case TemplateType::STYLE_TEMPLATE:
                m_StyleTemplates[templateNode->GetTemplateName()] = templateNode;
                break;
            case TemplateType::ELEMENT_TEMPLATE:
                m_ElementTemplates[templateNode->GetTemplateName()] = templateNode;
                break;
            case TemplateType::VAR_TEMPLATE:
                m_VarTemplates[templateNode->GetTemplateName()] = templateNode;
                break;
        }
    }
    
    // 收集自定义定义
    if (node->GetType() == CHTLNodeType::CUSTOM_STYLE_NODE ||
        node->GetType() == CHTLNodeType::CUSTOM_ELEMENT_NODE ||
        node->GetType() == CHTLNodeType::CUSTOM_VAR_NODE) {
        
        CustomNode* customNode = static_cast<CustomNode*>(node);
        
        switch (customNode->GetCustomType()) {
            case CustomType::STYLE_CUSTOM:
                m_StyleCustoms[customNode->GetCustomName()] = customNode;
                break;
            case CustomType::ELEMENT_CUSTOM:
                m_ElementCustoms[customNode->GetCustomName()] = customNode;
                break;
            case CustomType::VAR_CUSTOM:
                m_VarCustoms[customNode->GetCustomName()] = customNode;
                break;
        }
    }
    
    // 递归处理子节点
    for (const auto& child : node->GetChildren()) {
        CollectTemplatesAndCustoms(child.get());
    }
}

void CHTLGenerator::GenerateLocalStyleGlobalCSS(StyleNode* styleNode, ElementNode* contextElement) {
    if (!styleNode || !contextElement) {
        return;
    }
    
    // 生成局部样式块的全局CSS
    const auto& styleRules = styleNode->GetStyleRules();
    
    for (const auto& rule : styleRules) {
        if (rule.IsGlobalStyle && !rule.Selector.empty()) {
            std::string resolvedSelector = rule.Selector;
            
            // 处理上下文引用
            if (rule.Selector.find('&') != std::string::npos) {
                resolvedSelector = ResolveContextReference(rule.Selector, 
                                                          contextElement->GetFirstAutoClass(),
                                                          contextElement->GetFirstAutoId());
            }
            
            GenerateSelectorCSSRule(resolvedSelector, rule.Properties);
        }
    }
}

void CHTLGenerator::GenerateLocalScriptJavaScript(ScriptNode* scriptNode, ElementNode* contextElement) {
    if (!scriptNode || !contextElement) {
        return;
    }
    
    // 生成局部脚本块的JavaScript
    std::string jsCode = scriptNode->GenerateJavaScript(contextElement->GetFirstAutoClass(),
                                                        contextElement->GetFirstAutoId());
    
    if (!jsCode.empty()) {
        if (m_AddSourceComments) {
            m_GeneratedJS += AddSourceComment("Local script from " + contextElement->GetTagName(), "JS");
        }
        
        m_GeneratedJS += jsCode + "\n";
    }
}

void CHTLGenerator::GenerateSelectorCSSRule(const std::string& selector, 
                                           const std::unordered_map<std::string, std::string>& properties) {
    if (properties.empty()) {
        return;
    }
    
    std::ostringstream css;
    
    css << selector << " {\n";
    
    for (const auto& prop : properties) {
        css << "  " << prop.first << ": " << prop.second << ";\n";
    }
    
    css << "}\n\n";
    
    m_GeneratedCSS += css.str();
}

std::string CHTLGenerator::ResolveContextReference(const std::string& selector, 
                                                  const std::string& contextClass, 
                                                  const std::string& contextId) {
    std::string result = selector;
    
    // 局部style优先选择class
    std::string contextSelector;
    if (!contextClass.empty()) {
        contextSelector = "." + contextClass;
    }
    else if (!contextId.empty()) {
        contextSelector = "#" + contextId;
    }
    
    if (!contextSelector.empty()) {
        // 替换&引用
        std::regex contextPattern(R"(&)");
        result = std::regex_replace(result, contextPattern, contextSelector);
    }
    
    return result;
}

std::string CHTLGenerator::GenerateIndent(int level) {
    if (level == -1) {
        level = m_IndentLevel;
    }
    
    return std::string(level * 2, ' ');
}

std::string CHTLGenerator::AddSourceComment(const std::string& comment, const std::string& type) {
    if (!m_AddSourceComments) {
        return "";
    }
    
    if (type == "HTML") {
        return "<!-- " + comment + " -->\n";
    }
    else if (type == "CSS") {
        return "/* " + comment + " */\n";
    }
    else if (type == "JS") {
        return "// " + comment + "\n";
    }
    
    return "";
}

std::string CHTLGenerator::EscapeHTML(const std::string& text) {
    std::string result = text;
    
    // HTML字符转义
    std::regex htmlEscapePatterns[] = {
        std::regex("&"),
        std::regex("<"),
        std::regex(">"),
        std::regex("\""),
        std::regex("'")
    };
    
    std::string htmlEscapeReplacements[] = {
        "&amp;", "&lt;", "&gt;", "&quot;", "&#39;"
    };
    
    for (size_t i = 0; i < 5; ++i) {
        result = std::regex_replace(result, htmlEscapePatterns[i], htmlEscapeReplacements[i]);
    }
    
    return result;
}

std::string CHTLGenerator::ProcessUTF8Text(const std::string& text) {
    // 确保UTF-8字符正确处理
    return text; // 暂时直接返回，实际可能需要更复杂的处理
}

void CHTLGenerator::SetGenerationOptions(bool indentedHTML, bool minifyCSS, bool sourceComments) {
    m_GenerateIndentedHTML = indentedHTML;
    m_MinifyCSS = minifyCSS;
    m_AddSourceComments = sourceComments;
}

void CHTLGenerator::Reset() {
    // 重置生成器状态
    
    m_GeneratedHTML.clear();
    m_GeneratedCSS.clear();
    m_GeneratedJS.clear();
    
    m_StyleTemplates.clear();
    m_ElementTemplates.clear();
    m_VarTemplates.clear();
    m_StyleCustoms.clear();
    m_ElementCustoms.clear();
    m_VarCustoms.clear();
    
    m_GlobalStyleRules.clear();
    m_GlobalSelectors.clear();
    m_AutoClassMap.clear();
    m_AutoIdMap.clear();
    
    m_HasError = false;
    m_ErrorMessage.clear();
    m_Warnings.clear();
    m_IndentLevel = 0;
}

// 占位实现（需要后续完善）
void CHTLGenerator::ProcessTemplateInheritance() {
    // 处理模板继承逻辑
    for (auto& templatePair : m_StyleTemplates) {
        TemplateNode* templateNode = templatePair.second;
        
        // 应用继承规则
        for (const auto& inheritedTemplate : templateNode->GetInheritedTemplates()) {
            auto parentIt = m_StyleTemplates.find(inheritedTemplate);
            if (parentIt != m_StyleTemplates.end()) {
                templateNode->ApplyTemplateInheritance(parentIt->second);
            }
        }
    }
}

void CHTLGenerator::ProcessCustomInheritanceAndSpecialization() {
    // 处理自定义继承和特例化逻辑
}

void CHTLGenerator::ResolveVariableReferences() {
    // 解析变量引用逻辑
}

void CHTLGenerator::GenerateHTMLDocument(CHTLBaseNode* node) {
    if (node) {
        node->Accept(this);
    }
}

void CHTLGenerator::GenerateCSSStylesheet(CHTLBaseNode* node) {
    // CSS样式表生成逻辑已在访问者方法中实现
}

void CHTLGenerator::GenerateJavaScriptCode(CHTLBaseNode* node) {
    // JavaScript代码生成逻辑已在访问者方法中实现
}

bool CHTLGenerator::ValidateGeneratedCode() {
    // 验证生成的代码有效性
    return !m_GeneratedHTML.empty() || !m_GeneratedCSS.empty() || !m_GeneratedJS.empty();
}

void CHTLGenerator::OptimizeGeneratedCSS() {
    if (m_MinifyCSS) {
        // CSS压缩逻辑
        std::regex whitespacePattern(R"(\s+)");
        m_GeneratedCSS = std::regex_replace(m_GeneratedCSS, whitespacePattern, " ");
        
        std::regex newlinePattern(R"(\n\s*)");
        m_GeneratedCSS = std::regex_replace(m_GeneratedCSS, newlinePattern, "");
    }
}

void CHTLGenerator::OptimizeGeneratedHTML() {
    // HTML优化逻辑
    if (!m_GenerateIndentedHTML) {
        // 移除多余的空白
        std::regex excessWhitespacePattern(R"(\n\s*\n)");
        m_GeneratedHTML = std::regex_replace(m_GeneratedHTML, excessWhitespacePattern, "\n");
    }
}

void CHTLGenerator::SetGenerationError(const std::string& message) {
    m_HasError = true;
    m_ErrorMessage = message;
}

void CHTLGenerator::AddGenerationWarning(const std::string& message) {
    m_Warnings.push_back(message);
}

std::string CHTLGenerator::ResolveVariableReference(const std::string& variableRef) {
    // 解析变量引用：ThemeColor(tableColor)
    std::regex varPattern(R"(([a-zA-Z][a-zA-Z0-9_]*)\(([a-zA-Z][a-zA-Z0-9_]*)\))");
    std::smatch match;
    
    if (std::regex_match(variableRef, match, varPattern)) {
        std::string varGroup = match[1].str();
        std::string varName = match[2].str();
        
        // 查找变量组模板
        auto templateIt = m_VarTemplates.find(varGroup);
        if (templateIt != m_VarTemplates.end()) {
            return templateIt->second->GetTemplateProperty(varName);
        }
        
        // 查找变量自定义
        auto customIt = m_VarCustoms.find(varGroup);
        if (customIt != m_VarCustoms.end()) {
            return customIt->second->GetCustomProperty(varName);
        }
    }
    
    return variableRef; // 无法解析，返回原值
}

std::unordered_map<std::string, std::string> CHTLGenerator::ExpandStyleTemplate(const std::string& templateName) {
    auto it = m_StyleTemplates.find(templateName);
    if (it != m_StyleTemplates.end()) {
        return it->second->GetTemplateProperties();
    }
    
    return {};
}

void CHTLGenerator::SetError(const std::string& message) {
    m_HasError = true;
    m_ErrorMessage = message;
    std::cerr << "CHTL Generator Error: " << message << std::endl;
}



} // namespace CHTL