#include "ModularCompilerDispatcher.h"
#include "../Core/ServiceLocator.h"
#include <iostream>
#include <sstream>

namespace CHTL {
namespace Components {

// ModularCompilerDispatcherÂÆûÁé∞
ModularCompilerDispatcher::ModularCompilerDispatcher() 
    : Core::ComponentBase("ModularCompilerDispatcher", "1.0.0"),
      m_ScannerComponent(nullptr), m_CHTLCompilerComponent(nullptr), m_CHTLJSCompilerComponent(nullptr) {
    
    AddDependency("UnifiedScanner");
    AddDependency("CHTLCompiler");
    AddDependency("CHTLJSCompiler");
    AddDependency("CodeMerger");
}

bool ModularCompilerDispatcher::Initialize() {
    SetState(Core::ComponentState::INITIALIZING);
    
    try {
        // ÂàùÂßãÂåñ‰ª£Á†ÅÂêàÂπ∂Âô®
        m_CodeMerger = std::make_unique<CHTLCodeMerger>();
        
        // ÂàùÂßãÂåñÁªÑ‰ª∂ÂºïÁî®
        if (!InitializeComponentReferences()) {
            SetState(Core::ComponentState::ERROR_STATE);
            return false;
        }
        
        SetState(Core::ComponentState::INITIALIZED);
        std::cout << "‚úÖ Ê®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®Â∑≤ÂàùÂßãÂåñ" << std::endl;
        return true;
        
    } catch (const std::exception& e) {
        SetState(Core::ComponentState::ERROR_STATE);
        std::cerr << "‚ùå Ê®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®ÂàùÂßãÂåñÂ§±Ë¥•: " << e.what() << std::endl;
        return false;
    }
}

bool ModularCompilerDispatcher::Start() {
    if (GetState() != Core::ComponentState::INITIALIZED) {
        return false;
    }
    
    if (!CheckComponentDependencies()) {
        std::cerr << "‚ùå ÁªÑ‰ª∂‰æùËµñÊ£ÄÊü•Â§±Ë¥•" << std::endl;
        return false;
    }
    
    SetState(Core::ComponentState::RUNNING);
    std::cout << "üöÄ Ê®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®Â∑≤ÂêØÂä®" << std::endl;
    return true;
}

bool ModularCompilerDispatcher::Stop() {
    SetState(Core::ComponentState::STOPPED);
    std::cout << "‚èπÔ∏è Ê®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®Â∑≤ÂÅúÊ≠¢" << std::endl;
    return true;
}

void ModularCompilerDispatcher::Reset() {
    m_Fragments.clear();
    m_FragmentsByType.clear();
    m_CurrentSourceFile.clear();
    
    if (m_CodeMerger) {
        m_CodeMerger->Reset();
    }
    
    std::cout << "üîÑ Ê®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®Â∑≤ÈáçÁΩÆ" << std::endl;
}

bool ModularCompilerDispatcher::Compile(const std::string& sourceCode, const std::string& sourceFile) {
    if (GetState() != Core::ComponentState::RUNNING) {
        std::cerr << "‚ùå Ë∞ÉÂ∫¶Âô®Êú™ËøêË°å" << std::endl;
        return false;
    }
    
    m_CurrentSourceFile = sourceFile;
    
    try {
        // Ê≠•È™§1: ÊâßË°å‰ª£Á†ÅÊâ´Êèè
        if (!PerformScanning(sourceCode)) {
            std::cerr << "‚ùå ‰ª£Á†ÅÊâ´ÊèèÂ§±Ë¥•" << std::endl;
            return false;
        }
        
        // Ê≠•È™§2: ÊåâÁ±ªÂûãÂàÜÁªÑÁâáÊÆµ
        GroupFragmentsByType();
        
        // Ê≠•È™§3: ÁºñËØëÂêÑÁ±ªÂûãÁâáÊÆµ
        std::string chtlResult = CompileCHTLFragments(m_FragmentsByType[FragmentType::CHTL_FRAGMENT]);
        std::string chtljsResult = CompileCHTLJSFragments(m_FragmentsByType[FragmentType::CHTL_JS_FRAGMENT]);
        
        // Ê≠•È™§4: ÂêàÂπ∂ÁºñËØëÁªìÊûú
        std::string finalHTML = MergeCompilationResults(chtlResult, chtljsResult);
        
        std::cout << "‚úÖ ÁºñËØëÂÆåÊàê: " << finalHTML.size() << " Â≠óÁ¨¶" << std::endl;
        return !finalHTML.empty();
        
    } catch (const std::exception& e) {
        std::cerr << "‚ùå ÁºñËØëÂºÇÂ∏∏: " << e.what() << std::endl;
        return false;
    }
}

bool ModularCompilerDispatcher::InitializeComponentReferences() {
    auto& serviceLocator = Core::ServiceLocator::GetInstance();
    
    // Ëé∑ÂèñÊâ´ÊèèÂô®ÁªÑ‰ª∂
    m_ScannerComponent = serviceLocator.GetService<UnifiedScannerComponent>();
    if (!m_ScannerComponent) {
        std::cerr << "‚ùå Êó†Ê≥ïËé∑ÂèñÁªü‰∏ÄÊâ´ÊèèÂô®ÁªÑ‰ª∂" << std::endl;
        return false;
    }
    
    // Ëé∑ÂèñCHTLÁºñËØëÂô®ÁªÑ‰ª∂
    m_CHTLCompilerComponent = serviceLocator.GetService<CHTLCompilerComponent>();
    if (!m_CHTLCompilerComponent) {
        std::cerr << "‚ùå Êó†Ê≥ïËé∑ÂèñCHTLÁºñËØëÂô®ÁªÑ‰ª∂" << std::endl;
        return false;
    }
    
    // Ëé∑ÂèñCHTL JSÁºñËØëÂô®ÁªÑ‰ª∂
    m_CHTLJSCompilerComponent = serviceLocator.GetService<CHTLJSCompilerComponent>();
    if (!m_CHTLJSCompilerComponent) {
        std::cerr << "‚ùå Êó†Ê≥ïËé∑ÂèñCHTL JSÁºñËØëÂô®ÁªÑ‰ª∂" << std::endl;
        return false;
    }
    
    std::cout << "‚úÖ ÁªÑ‰ª∂ÂºïÁî®Â∑≤ÂàùÂßãÂåñ" << std::endl;
    return true;
}

bool ModularCompilerDispatcher::PerformScanning(const std::string& sourceCode) {
    if (!m_ScannerComponent) {
        return false;
    }
    
    bool scanResult = m_ScannerComponent->Scan(sourceCode);
    
    if (scanResult) {
        m_Fragments = m_ScannerComponent->GetFragments();
        std::cout << "üìÑ Êâ´ÊèèÂÆåÊàê: " << m_Fragments.size() << " ‰∏™ÁâáÊÆµ" << std::endl;
    }
    
    return scanResult;
}

void ModularCompilerDispatcher::GroupFragmentsByType() {
    m_FragmentsByType.clear();
    
    for (const auto& fragment : m_Fragments) {
        m_FragmentsByType[fragment.Type].push_back(fragment);
    }
    
    std::cout << "üìä ÁâáÊÆµÂàÜÁªÑÂÆåÊàê:" << std::endl;
    for (const auto& pair : m_FragmentsByType) {
        std::cout << "  " << static_cast<int>(pair.first) << " Á±ªÂûã: " << pair.second.size() << " ‰∏™ÁâáÊÆµ" << std::endl;
    }
}

std::string ModularCompilerDispatcher::CompileCHTLFragments(const std::vector<CodeFragment>& fragments) {
    if (!m_CHTLCompilerComponent || fragments.empty()) {
        return "";
    }
    
    std::ostringstream result;
    
    for (const auto& fragment : fragments) {
        std::string compiled = m_CHTLCompilerComponent->Compile(fragment.Content);
        if (!compiled.empty()) {
            result << compiled << "\n";
        }
    }
    
    return result.str();
}

std::string ModularCompilerDispatcher::CompileCHTLJSFragments(const std::vector<CodeFragment>& fragments) {
    if (!m_CHTLJSCompilerComponent || fragments.empty()) {
        return "";
    }
    
    std::ostringstream result;
    
    for (const auto& fragment : fragments) {
        std::string compiled = m_CHTLJSCompilerComponent->Compile(fragment.Content);
        if (!compiled.empty()) {
            result << compiled << "\n";
        }
    }
    
    return result.str();
}

std::string ModularCompilerDispatcher::MergeCompilationResults(const std::string& chtlResult, const std::string& chtljsResult) {
    if (!m_CodeMerger) {
        return chtlResult + chtljsResult;
    }
    
    try {
        // ‰ΩøÁî®‰ª£Á†ÅÂêàÂπ∂Âô®ÂêàÂπ∂ÁªìÊûú
        std::vector<MergerCodeFragment> fragments;
        
        if (!chtlResult.empty()) {
            MergerCodeFragment chtlFragment;
            chtlFragment.Content = chtlResult;
            chtlFragment.Type = MergerFragmentType::HTML;
            fragments.push_back(chtlFragment);
        }
        
        if (!chtljsResult.empty()) {
            MergerCodeFragment jsFragment;
            jsFragment.Content = chtljsResult;
            jsFragment.Type = MergerFragmentType::JAVASCRIPT;
            fragments.push_back(jsFragment);
        }
        
        return m_CodeMerger->MergeFragments(fragments);
        
    } catch (const std::exception& e) {
        std::cerr << "‚ùå ‰ª£Á†ÅÂêàÂπ∂ÂºÇÂ∏∏: " << e.what() << std::endl;
        return chtlResult + chtljsResult;
    }
}

bool ModularCompilerDispatcher::CheckComponentDependencies() {
    return m_ScannerComponent && m_CHTLCompilerComponent && m_CHTLJSCompilerComponent;
}

std::string ModularCompilerDispatcher::GetCompiledHTML() const {
    // TODO: ÂÆûÁé∞Ëé∑ÂèñÊúÄÁªàHTMLÁªìÊûú
    return "";
}

std::vector<std::string> ModularCompilerDispatcher::GetCompilationErrors() const {
    std::vector<std::string> allErrors;
    
    // Êî∂ÈõÜÂêÑÁªÑ‰ª∂ÁöÑÈîôËØØ
    if (m_CHTLCompilerComponent) {
        auto chtlErrors = m_CHTLCompilerComponent->GetErrorHandler();
        if (chtlErrors) {
            auto errors = chtlErrors->GetErrorsByLevel(ErrorLevel::ERROR);
            for (const auto& error : errors) {
                allErrors.push_back(error.GetMessage());
            }
        }
    }
    
    if (m_CHTLJSCompilerComponent) {
        auto chtljsErrors = m_CHTLJSCompilerComponent->GetErrorHandler();
        if (chtljsErrors) {
            auto errors = chtljsErrors->GetErrorsByLevel(ErrorLevel::ERROR);
            for (const auto& error : errors) {
                allErrors.push_back(error.GetMessage());
            }
        }
    }
    
    return allErrors;
}

std::vector<std::string> ModularCompilerDispatcher::GetCompilationWarnings() const {
    std::vector<std::string> allWarnings;
    
    // Êî∂ÈõÜÂêÑÁªÑ‰ª∂ÁöÑË≠¶Âëä
    if (m_CHTLCompilerComponent) {
        auto chtlErrors = m_CHTLCompilerComponent->GetErrorHandler();
        if (chtlErrors) {
            auto warnings = chtlErrors->GetErrorsByLevel(ErrorLevel::WARNING);
            for (const auto& warning : warnings) {
                allWarnings.push_back(warning.GetMessage());
            }
        }
    }
    
    if (m_CHTLJSCompilerComponent) {
        auto chtljsErrors = m_CHTLJSCompilerComponent->GetErrorHandler();
        if (chtljsErrors) {
            auto warnings = chtljsErrors->GetErrorsByLevel(ErrorLevel::WARNING);
            for (const auto& warning : warnings) {
                allWarnings.push_back(warning.GetMessage());
            }
        }
    }
    
    return allWarnings;
}

std::unordered_map<std::string, size_t> ModularCompilerDispatcher::GetCompilationStatistics() const {
    std::unordered_map<std::string, size_t> stats;
    
    stats["total_fragments"] = m_Fragments.size();
    stats["chtl_fragments"] = m_FragmentsByType.count(FragmentType::CHTL_FRAGMENT) ? 
                             m_FragmentsByType.at(FragmentType::CHTL_FRAGMENT).size() : 0;
    stats["chtljs_fragments"] = m_FragmentsByType.count(FragmentType::CHTL_JS_FRAGMENT) ?
                               m_FragmentsByType.at(FragmentType::CHTL_JS_FRAGMENT).size() : 0;
    
    // ÂêàÂπ∂ÂêÑÁªÑ‰ª∂ÁªüËÆ°
    if (m_CHTLCompilerComponent) {
        auto chtlStats = m_CHTLCompilerComponent->GetCompilationStats();
        for (const auto& pair : chtlStats) {
            stats["chtl_" + pair.first] = pair.second;
        }
    }
    
    if (m_CHTLJSCompilerComponent) {
        auto chtljsStats = m_CHTLJSCompilerComponent->GetCompilationStats();
        for (const auto& pair : chtljsStats) {
            stats["chtljs_" + pair.first] = pair.second;
        }
    }
    
    return stats;
}

// CompilerFactoryÂÆûÁé∞
bool CompilerFactory::CreateStandardConfiguration() {
    try {
        // Ê≥®ÂÜåÊâÄÊúâÁºñËØëÂô®ÁªÑ‰ª∂
        size_t registeredCount = RegisterAllCompilerComponents();
        
        std::cout << "üì¶ Â∑≤Ê≥®ÂÜå " << registeredCount << " ‰∏™ÁºñËØëÂô®ÁªÑ‰ª∂" << std::endl;
        
        // ÂêØÂä®ÁªÑ‰ª∂ÁÆ°ÁêÜÂô®
        auto& componentManager = Core::ComponentManager::GetInstance();
        if (!componentManager.Initialize()) {
            return false;
        }
        
        // ÂêØÂä®ÊâÄÊúâÁªÑ‰ª∂
        size_t startedCount = componentManager.StartAllComponents();
        std::cout << "üöÄ Â∑≤ÂêØÂä® " << startedCount << " ‰∏™ÁªÑ‰ª∂" << std::endl;
        
        return ValidateCompilerConfiguration();
        
    } catch (const std::exception& e) {
        std::cerr << "‚ùå Ê†áÂáÜÈÖçÁΩÆÂàõÂª∫Â§±Ë¥•: " << e.what() << std::endl;
        return false;
    }
}

size_t CompilerFactory::RegisterAllCompilerComponents() {
    RegisterCoreComponents();
    RegisterCompilerComponents();
    RegisterUtilityComponents();
    
    // ËøîÂõûÊ≥®ÂÜåÁöÑÁªÑ‰ª∂Êï∞Èáè
    return Core::ComponentManager::GetInstance().GetRegisteredComponents().size();
}

std::unique_ptr<ModularCompilerDispatcher> CompilerFactory::CreateModularDispatcher() {
    auto dispatcher = std::make_unique<ModularCompilerDispatcher>();
    
    if (dispatcher->Initialize() && dispatcher->Start()) {
        std::cout << "‚úÖ Ê®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®ÂàõÂª∫ÊàêÂäü" << std::endl;
        return dispatcher;
    }
    
    std::cerr << "‚ùå Ê®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®ÂàõÂª∫Â§±Ë¥•" << std::endl;
    return nullptr;
}

bool CompilerFactory::ValidateCompilerConfiguration() {
    auto& componentManager = Core::ComponentManager::GetInstance();
    
    // Ê£ÄÊü•ÂÖ≥ÈîÆÁªÑ‰ª∂ÊòØÂê¶Â≠òÂú®
    std::vector<std::string> requiredComponents = {
        "UnifiedScanner", "CHTLCompiler", "CHTLJSCompiler"
    };
    
    for (const auto& componentName : requiredComponents) {
        if (!componentManager.ComponentExists(componentName)) {
            std::cerr << "‚ùå Áº∫Â∞ëÂøÖÈúÄÁªÑ‰ª∂: " << componentName << std::endl;
            return false;
        }
        
        auto state = componentManager.GetComponentState(componentName);
        if (state != Core::ComponentState::RUNNING && state != Core::ComponentState::INITIALIZED) {
            std::cerr << "‚ùå ÁªÑ‰ª∂Áä∂ÊÄÅÂºÇÂ∏∏: " << componentName << std::endl;
            return false;
        }
    }
    
    std::cout << "‚úÖ ÁºñËØëÂô®ÈÖçÁΩÆÈ™åËØÅÈÄöËøá" << std::endl;
    return true;
}

void CompilerFactory::RegisterCoreComponents() {
    auto& componentManager = Core::ComponentManager::GetInstance();
    
    // Ê≥®ÂÜåÁªü‰∏ÄÊâ´ÊèèÂô®ÁªÑ‰ª∂
    componentManager.RegisterComponent<UnifiedScannerComponent>(
        "UnifiedScanner", "1.0.0", "Áªü‰∏Ä‰ª£Á†ÅÊâ´ÊèèÂô®ÁªÑ‰ª∂"
    );
}

void CompilerFactory::RegisterCompilerComponents() {
    auto& componentManager = Core::ComponentManager::GetInstance();
    
    // Ê≥®ÂÜåCHTLÁºñËØëÂô®ÁªÑ‰ª∂
    componentManager.RegisterComponent<CHTLCompilerComponent>(
        "CHTLCompiler", "1.0.0", "CHTLËØ≠Ë®ÄÁºñËØëÂô®ÁªÑ‰ª∂"
    );
    
    // Ê≥®ÂÜåCHTL JSÁºñËØëÂô®ÁªÑ‰ª∂
    componentManager.RegisterComponent<CHTLJSCompilerComponent>(
        "CHTLJSCompiler", "1.0.0", "CHTL JSËØ≠Ë®ÄÁºñËØëÂô®ÁªÑ‰ª∂"
    );
}

void CompilerFactory::RegisterUtilityComponents() {
    auto& componentManager = Core::ComponentManager::GetInstance();
    
    // Ê≥®ÂÜåÊ®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®
    componentManager.RegisterComponent<ModularCompilerDispatcher>(
        "ModularDispatcher", "1.0.0", "Ê®°ÂùóÂåñÁºñËØëÂô®Ë∞ÉÂ∫¶Âô®"
    );
}

} // namespace Components
} // namespace CHTL