#include "ElementNode.h"
#include "Visitor.h"
#include <algorithm>
#include <sstream>
#include <unordered_set>
#include <regex>

namespace CHTL {

ElementNode::ElementNode(const std::string& tagName, size_t line, size_t column)
    : CHTLBaseNode(CHTLNodeType::ELEMENT_NODE, tagName, line, column), 
      m_TagName(tagName), m_IsSelfClosing(false), m_IsBlockLevel(true) {
    
    InitializeHTMLTagProperties();
}

void ElementNode::SetTagName(const std::string& tagName) {
    m_TagName = tagName;
    SetName(tagName);
    InitializeHTMLTagProperties();
}

void ElementNode::InitializeHTMLTagProperties() {
    // 检查是否为有效的HTML标签
    if (!IsValidHTMLTag(m_TagName)) {
        // 如果不是标准HTML标签，可能是自定义元素
        m_IsSelfClosing = false;
        m_IsBlockLevel = true;
        return;
    }
    
    // 设置自闭合标签属性
    m_IsSelfClosing = IsSelfClosingTag(m_TagName);
    
    // 设置块级元素属性
    m_IsBlockLevel = IsBlockLevelTag(m_TagName);
}

bool ElementNode::IsValidHTMLTag(const std::string& tagName) const {
    static const std::unordered_set<std::string> validHTMLTags = {
        // 基础结构标签
        "html", "head", "body", "title", "meta", "link", "style", "script",
        
        // 块级元素
        "div", "p", "h1", "h2", "h3", "h4", "h5", "h6", "header", "footer", 
        "nav", "section", "article", "aside", "main", "figure", "figcaption",
        "blockquote", "pre", "address", "hr",
        
        // 列表元素
        "ul", "ol", "li", "dl", "dt", "dd",
        
        // 表格元素
        "table", "thead", "tbody", "tfoot", "tr", "td", "th", "caption", "colgroup", "col",
        
        // 表单元素
        "form", "input", "button", "select", "option", "optgroup", "textarea", 
        "label", "fieldset", "legend", "datalist", "output",
        
        // 行内元素
        "span", "a", "strong", "em", "b", "i", "u", "s", "small", "mark", 
        "del", "ins", "sub", "sup", "code", "kbd", "samp", "var", "time",
        
        // 媒体元素
        "img", "video", "audio", "source", "track", "canvas", "svg",
        
        // 其他元素
        "iframe", "embed", "object", "param", "details", "summary", "dialog"
    };
    
    return validHTMLTags.find(tagName) != validHTMLTags.end();
}

bool ElementNode::IsSelfClosingTag(const std::string& tagName) const {
    static const std::unordered_set<std::string> selfClosingTags = {
        "area", "base", "br", "col", "embed", "hr", "img", "input", 
        "link", "meta", "param", "source", "track", "wbr"
    };
    
    return selfClosingTags.find(tagName) != selfClosingTags.end();
}

bool ElementNode::IsBlockLevelTag(const std::string& tagName) const {
    static const std::unordered_set<std::string> blockLevelTags = {
        "div", "p", "h1", "h2", "h3", "h4", "h5", "h6", "header", "footer",
        "nav", "section", "article", "aside", "main", "figure", "figcaption",
        "blockquote", "pre", "address", "hr", "ul", "ol", "li", "dl", "dt", "dd",
        "table", "thead", "tbody", "tfoot", "tr", "td", "th", "form", "fieldset"
    };
    
    return blockLevelTags.find(tagName) != blockLevelTags.end();
}

void ElementNode::AddStyleNode(std::unique_ptr<CHTLBaseNode> styleNode) {
    if (styleNode && styleNode->GetType() == CHTLNodeType::STYLE_NODE) {
        styleNode->SetParent(this);
        m_StyleNodes.push_back(std::move(styleNode));
    }
}

void ElementNode::AddScriptNode(std::unique_ptr<CHTLBaseNode> scriptNode) {
    if (scriptNode && scriptNode->GetType() == CHTLNodeType::SCRIPT_NODE) {
        scriptNode->SetParent(this);
        m_ScriptNodes.push_back(std::move(scriptNode));
    }
}

void ElementNode::AddConstraint(const std::string& constraint) {
    m_Constraints.insert(constraint);
}

bool ElementNode::CheckConstraint(const std::string& elementType) const {
    // 检查是否违反约束
    if (m_Constraints.find(elementType) != m_Constraints.end()) {
        return false; // 违反约束
    }
    
    // 检查类型约束
    if (m_Constraints.find("@Html") != m_Constraints.end()) {
        return false; // 禁止HTML元素
    }
    
    if (m_Constraints.find("[Custom]") != m_Constraints.end() && 
        elementType.find("[Custom]") != std::string::npos) {
        return false; // 禁止自定义类型
    }
    
    if (m_Constraints.find("[Template]") != m_Constraints.end() && 
        elementType.find("[Template]") != std::string::npos) {
        return false; // 禁止模板类型
    }
    
    return true; // 通过约束检查
}

void ElementNode::AddAutoGeneratedClass(const std::string& className) {
    if (std::find(m_AutoGeneratedClasses.begin(), m_AutoGeneratedClasses.end(), className) 
        == m_AutoGeneratedClasses.end()) {
        m_AutoGeneratedClasses.push_back(className);
        SetAutoClassName(className);
    }
}

void ElementNode::AddAutoGeneratedId(const std::string& idName) {
    if (std::find(m_AutoGeneratedIds.begin(), m_AutoGeneratedIds.end(), idName) 
        == m_AutoGeneratedIds.end()) {
        m_AutoGeneratedIds.push_back(idName);
        SetAutoIdName(idName);
    }
}

std::string ElementNode::GetFirstAutoClass() const {
    return m_AutoGeneratedClasses.empty() ? "" : m_AutoGeneratedClasses[0];
}

std::string ElementNode::GetFirstAutoId() const {
    return m_AutoGeneratedIds.empty() ? "" : m_AutoGeneratedIds[0];
}

void ElementNode::ApplySelectorAutomation(bool disableClassAuto, bool disableIdAuto) {
    // 应用选择器自动化规则
    
    // 检查局部样式块中的选择器
    for (const auto& styleNode : m_StyleNodes) {
        const std::string& styleContent = styleNode->GetContent();
        
        // 查找类选择器
        if (!disableClassAuto) {
            std::regex classPattern(R"(\.([a-zA-Z][a-zA-Z0-9\-_]*))");
            std::sregex_iterator iter(styleContent.begin(), styleContent.end(), classPattern);
            std::sregex_iterator end;
            
            for (; iter != end; ++iter) {
                std::smatch match = *iter;
                std::string className = match[1].str();
                AddAutoGeneratedClass(className);
            }
        }
        
        // 查找ID选择器
        if (!disableIdAuto) {
            std::regex idPattern(R"(#([a-zA-Z][a-zA-Z0-9\-_]*))");
            std::sregex_iterator iter(styleContent.begin(), styleContent.end(), idPattern);
            std::sregex_iterator end;
            
            for (; iter != end; ++iter) {
                std::smatch match = *iter;
                std::string idName = match[1].str();
                AddAutoGeneratedId(idName);
            }
        }
    }
    
    // 如果没有class属性但有自动类名，添加第一个类名
    if (!HasAttribute("class") && !m_AutoGeneratedClasses.empty()) {
        SetAttribute("class", m_AutoGeneratedClasses[0]);
    }
    
    // 如果没有id属性但有自动ID，添加第一个ID
    if (!HasAttribute("id") && !m_AutoGeneratedIds.empty()) {
        SetAttribute("id", m_AutoGeneratedIds[0]);
    }
}

std::string ElementNode::GenerateOpenTag() const {
    std::ostringstream tag;
    tag << "<" << m_TagName;
    
    // 添加属性
    for (const auto& attr : GetAttributes()) {
        tag << " " << attr.first << "=\"" << attr.second << "\"";
    }
    
    // 处理内联样式
    std::string inlineStyle = GenerateInlineStyle();
    if (!inlineStyle.empty()) {
        tag << " style=\"" << inlineStyle << "\"";
    }
    
    if (m_IsSelfClosing) {
        tag << " />";
    }
    else {
        tag << ">";
    }
    
    return tag.str();
}

std::string ElementNode::GenerateCloseTag() const {
    if (m_IsSelfClosing) {
        return "";
    }
    
    return "</" + m_TagName + ">";
}

std::string ElementNode::GenerateHTMLElement() const {
    std::ostringstream html;
    
    // 生成开始标签
    html << GenerateOpenTag();
    
    if (!m_IsSelfClosing) {
        // 生成子元素内容
        for (const auto& child : GetChildren()) {
            if (child->GetType() == CHTLNodeType::TEXT_NODE) {
                html << child->GetContent();
            }
            else if (child->GetType() == CHTLNodeType::ELEMENT_NODE) {
                ElementNode* childElement = static_cast<ElementNode*>(child.get());
                html << childElement->GenerateHTMLElement();
            }
        }
        
        // 生成结束标签
        html << GenerateCloseTag();
    }
    
    return html.str();
}

std::string ElementNode::GenerateInlineStyle() const {
    std::ostringstream style;
    
    bool first = true;
    for (const auto& prop : GetProperties()) {
        if (!first) {
            style << "; ";
        }
        style << prop.first << ": " << prop.second;
        first = false;
    }
    
    return style.str();
}

void ElementNode::Accept(CHTLNodeVisitor* visitor) {
    if (visitor) {
        visitor->VisitElementNode(this);
    }
}

std::unique_ptr<CHTLBaseNode> ElementNode::Clone() const {
    auto cloned = std::make_unique<ElementNode>(m_TagName, GetLine(), GetColumn());
    
    // 复制基础属性
    cloned->SetContent(GetContent());
    cloned->SetNamespace(GetNamespace());
    cloned->m_IsSelfClosing = m_IsSelfClosing;
    cloned->m_IsBlockLevel = m_IsBlockLevel;
    cloned->m_Constraints = m_Constraints;
    cloned->m_AutoGeneratedClasses = m_AutoGeneratedClasses;
    cloned->m_AutoGeneratedIds = m_AutoGeneratedIds;
    
    // 复制属性和CSS属性
    for (const auto& attr : GetAttributes()) {
        cloned->SetAttribute(attr.first, attr.second);
    }
    
    for (const auto& prop : GetProperties()) {
        cloned->SetProperty(prop.first, prop.second);
    }
    
    // 克隆子节点
    for (const auto& child : GetChildren()) {
        cloned->AddChild(child->Clone());
    }
    
    // 克隆样式节点
    for (const auto& styleNode : m_StyleNodes) {
        cloned->AddStyleNode(styleNode->Clone());
    }
    
    // 克隆脚本节点
    for (const auto& scriptNode : m_ScriptNodes) {
        cloned->AddScriptNode(scriptNode->Clone());
    }
    
    return cloned;
}

std::string ElementNode::ToString(int indent) const {
    std::ostringstream oss;
    std::string indentStr = GenerateIndent(indent);
    
    oss << indentStr << "ElementNode '" << m_TagName << "'";
    
    if (!GetAttributes().empty()) {
        oss << " [";
        bool first = true;
        for (const auto& attr : GetAttributes()) {
            if (!first) oss << ", ";
            oss << attr.first << "=" << attr.second;
            first = false;
        }
        oss << "]";
    }
    
    if (m_IsSelfClosing) {
        oss << " [SelfClosing]";
    }
    
    if (!m_IsBlockLevel) {
        oss << " [Inline]";
    }
    
    if (HasAutoClass()) {
        oss << " [AutoClass: " << GetAutoClassName() << "]";
    }
    
    if (HasAutoId()) {
        oss << " [AutoId: " << GetAutoIdName() << "]";
    }
    
    if (!m_Constraints.empty()) {
        oss << " [Constraints: " << m_Constraints.size() << "]";
    }
    
    oss << " @(" << GetLine() << ":" << GetColumn() << ")\n";
    
    // 输出样式节点
    if (!m_StyleNodes.empty()) {
        oss << indentStr << "  Styles:\n";
        for (const auto& styleNode : m_StyleNodes) {
            oss << styleNode->ToString(indent + 2);
        }
    }
    
    // 输出脚本节点
    if (!m_ScriptNodes.empty()) {
        oss << indentStr << "  Scripts:\n";
        for (const auto& scriptNode : m_ScriptNodes) {
            oss << scriptNode->ToString(indent + 2);
        }
    }
    
    // 输出子节点
    for (const auto& child : GetChildren()) {
        oss << child->ToString(indent + 1);
    }
    
    return oss.str();
}

void ElementNode::ProcessCEEquivalence(std::unordered_map<std::string, std::string>& attributes) {
    // CE对等式处理：':'与'='完全等价
    // 这个在解析阶段已经处理，这里主要用于验证
    
    for (auto& attr : attributes) {
        // 确保属性值格式正确
        std::string& value = attr.second;
        
        // 移除可能的分号
        if (!value.empty() && value.back() == ';') {
            value.pop_back();
        }
        
        // 处理无修饰字面量
        if (value.find('"') == std::string::npos && value.find('\'') == std::string::npos) {
            // 这是无修饰字面量，保持原样
        }
    }
}

std::string ElementNode::ProcessContextReference(const std::string& styleContent) {
    std::string result = styleContent;
    
    // 处理&引用（优先选择class）
    std::string contextSelector;
    
    if (HasAutoClass()) {
        contextSelector = "." + GetFirstAutoClass();
    }
    else if (HasAutoId()) {
        contextSelector = "#" + GetFirstAutoId();
    }
    else if (HasAttribute("class")) {
        contextSelector = "." + GetAttribute("class");
    }
    else if (HasAttribute("id")) {
        contextSelector = "#" + GetAttribute("id");
    }
    
    if (!contextSelector.empty()) {
        // 替换&引用
        std::regex contextPattern(R"(&(?=\s*:))");
        result = std::regex_replace(result, contextPattern, contextSelector);
    }
    
    return result;
}

void ElementNode::AddInlineStyle(const std::string& property, const std::string& value) {
    if (!property.empty() && !value.empty()) {
        m_InlineStyles[property] = value;
    }
}

void ElementNode::InsertChild(size_t position, std::unique_ptr<CHTLBaseNode> child) {
    if (!child) {
        return;
    }
    
    auto& children = const_cast<std::vector<std::unique_ptr<CHTLBaseNode>>&>(GetChildren());
    
    if (position >= children.size()) {
        children.push_back(std::move(child));
    } else {
        children.insert(children.begin() + position, std::move(child));
    }
}

} // namespace CHTL